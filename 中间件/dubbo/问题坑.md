### Dubbo是什么？ 
Dubbo 是一个分布式、高性能、透明化的RPC服务框架，提供高效服务治理方案(服务自动注册、自动发现等)

### 异步调用坑(dubbo 2.5.4)
- A异步调用B， B同步调用C时，会转成异步调用
1. RpcContext是一个临时状态记录器，当接收到RPC请求，或发起RPC请求时，RpcContext的状态都会变化。
     在B调C之前，RpcContext记录的是A调B的信息，
     在B调C之后，RpcContext记录的是B调C的信息
2. 在RpcContext中的attachments(Map结构)属性中添加async=true的键值对，
3. 在A异步调用B时，B接受到A的rpc请求后做预处理时，ContextFilter会把attachement附加到RpcContext中。
   再B同步调用C时，会把attachment附加到RpcInvocation中，导致同步变异步。
                             
- 解决办法
1. 增加filter，删除RpcContext中的Constants.ASYNC_KEY。

### Provider线程池被EXHAUSTED 
https://www.iteye.com/blog/manzhizhen-2391177
- Provider角色，有IO线程池（默认无界）和业务处理线程池（默认200）两个线程池`

- 当Dispatcher使用all时，一旦Provider线程池被打满，由于异常处理也需要用业务线程池，
1.如果此时运气好，业务线程池有空闲线程，那么Consumer将收到Provider发送的线程池打满异常；
2.如果此时业务线程池还是满的，于是异常处理和应答步骤也没有线程可以跑，导致无法应答Consumer，
3.这也是为什么我们有时候能在Consumer看到线程池打满异常，有时候看到的确是超时异常
所以，为了减少在Provider线程池打满时整个系统雪崩的风险，建议将Dispatcher设置成message：

### 不支持分布式事务

### 超时
0.去掉重试次数，防止provider崩溃；
1.重新设置合理的超时时间                      
2.如果出现超时，通常是业务处理太慢，可在服务提供方执行：jstack PID > jstack.log 分析线程，进行调优

### 超时机制导致的雪崩连接-- 一次线上经验
https://blog.csdn.net/joeyon1985/article/details/51046605


### 剔除失效服务原理
zookeeper会话超时，一旦会话失效，那么ZK就开始清除和这个会话有关的信息，
包括这个会话创建的临时节点。

### Dubbo Monitor 实现原理？
Consumer 端在发起调用之前会先走 filter 链；provider 端在接收到请求时也是先走 filter 链，然后才进行真正的业务逻辑处理。
默认情况下，在consumer和provider的filter链中都会有Monitorfilter。

### Dubbo的核心功能？ 3个 
- Remoting：网络通信框架，提供对多种NIO框架抽象封装。包括“同步转异步”和“请求-响应”模式的信息交换方式。 
- Cluster：集群服务框架，提供基于接口方法的透明远程过程调用。包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。 
- Registry：注册服务，基于注册中心目录服务。使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。

### dubbo中的invoker
1.invoker是Dubbo的核心模型，其它模型都向它靠扰，或转换成它。
2.它代表一个可执行体，可向它发起invoke调用，
3.它有可能是一个本地的实现，也可能是一个远程的实现，也可能一个集群实现。

### rpc VS http接口调用
rpc框架是面向服务soa的更高级的封装，封装了"自动注册","“服务发现”，"负载均衡"，“熔断降级”一类面向服务的高级特性。针对服务的可用性和效率等都做了优化
一个http servlet容器上如果也封装一层服务发现和函数代理调用，那它就已经可以做一个rpc框架了
(rpc是远端过程调用，其调用的通信协议可以使用http； http接口调用使用的协议也是http； 这个不是区别)