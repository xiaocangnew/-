### 只用2G内存，在20亿数字中找出出现最多的数
1。 20亿数字需要9g多空间，2g不够用（1g空间可以存储2.56亿数字）
2。 只能将20亿数据分为16个文件，使用hash分，这样同一个数肯定在同一个文件中。
3。 统计每个文件出现最多的数。最后合并。

### 40亿非负整数上，找到没有出现过的数。 0-2的31次方，使用10M空间
1。10M = 10*1024*1024*8bit = 83886080 bit,
   BitMap bitMap = new BitMap(83886080);  //bitMap<int, boolean>;

2. 10M = 2的26次方， 31-26=5, 即在bitMap的每个位置上，都会出现32次。
   int[83886080] count数组上。失的那个数的位置上，只有31。
3.  申请bitMap，遍历数据一遍，只关心缺失数据段上的数据。
               
             
### 100亿个url中重复的url以及topk问题
1。 使用hash将url进行分流，保证相同的url在同一个文件中。
2。 topk问题时，使用k大小的小根堆。每个文件分别找出topk
3。 对所有文件再进行topk处理。 