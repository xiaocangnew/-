### sync,lock区别
- 1.一个接口，一个关键字，
    synchronized是内置的语言实现，lock是jdk实现；
- 2.死锁:
    synchronized异常时候会自动释放不会出现死锁；lock异常时候，不主动释放，必须手动unlock来释放锁，否则引起死锁。 
- 3.效率
     Lock可以通过读写锁实现读写分离，提高效率 
- 4.lock.interrupt(); lock.tryLock();
    synchronized不能响应中断；不能判断是否有锁，只能等待；
    
### lock接口
- 三顶级接口
    lock接口，readwriteLock接口，condition接口
- 读写锁，
    只有读读是可以并行的，读写，写写都是串行的，需要获取同一把锁，会竞争
    适用于读多写少的高并发场景
- lockInterruptibly()
    可以相应中断，打断尝试获取锁但失败等待的线程，
    不能打断正在运行的线程。
- 释放锁，
    在finally中释放，防止异常条件下走不到释放语句。
- 线程释放锁的几种情形：
    执行完任务；遇到异常；wait方法
- wait()方法和notify()方法在放弃对象监视器的时候的区别：
     wait()方法立即释放对象监视器
     notify()方法则会等待线程剩余代码执行完毕才会放弃对象监视器。
     
### 多线程释放同步锁
- 1.执行完同步代码块。
- 2.遇到异常而导致线程终止。
- 3.wait()方法，这个线程会释放锁，进行对象的等待池。

- 不会释放锁的情况：
    - 1.Thread.sleep()方法，当前线程放弃CPU，开始睡眠，在睡眠中不会释放锁。
    - 2.Thread.yield()方法，当前线程放弃CPU，但不会释放锁。
    - 3.在执行同步代码块的过程中，其他线程执行了当前对象的suspend()方法，当前线程被暂停，但不会释放锁。但Thread类的suspend()方法已经被废弃。


     
### 并发编程3要素
- 原子性：可见性：有序性：
     
- volatile 保证可见性(内存屏障)和有序性(禁止指令重排序)，但不保证原子性
  synchronized 保证原子性，有序性，可见性
       
### CAS  高效原子操作，由硬件保证
- 三大问题 
   - ABA问题，
       解决思路：使用版本号,在变量前面追加上版本号
       jdk1.5引入AtomicStampedReference来解决ABA问题
   - 循环时间长开销大
       并发量比较高的情况下，CAS如果长时间不成功，会给CPU带来非常大的执行开销
   - 只能保证一个共享变量的原子操作
      用锁，或者把多个共享变量合并成一个共享变量
      jdk1.5后引入AtomicReference类，可以把多变量放到这个类中
      
### 锁分类
- 悲观锁，
- 乐观锁，
   乐观锁的实现方式与悲观锁不同之处就在于乐观锁可以对竞争失败了的线程进行其他策略的处理，而悲观锁只能等待锁释放
- 自旋锁
    - 定义：当前线程不停地执行循环体，不进行线程状态的改变，所以响应速度更快
    - 使用场景：线程竞争不激烈，并且保持锁的时间段。   
- 偏向锁
- CAS锁

### 锁升级
无锁---> 偏向锁------> 自旋锁(轻量级锁) ------> 重量级锁
- 偏向锁
    - 优点： 加解锁不需要额外消耗，执行同步和异步方法是纳秒级差距
    - 缺点： 如果线程间存在锁竞争，有锁撤销的消耗
    - 场景： 一个线程访问同步块
    - 为什么引入
      因为经过研究发现，大多数时候是不存在锁竞争的，常常是一个线程多次获得同一个锁，因此如果每次都要竞争锁会增大很多没有必要付出的代价，为了降低获取锁的代价，才引入的偏向锁。
- 自旋锁
    - 优点： 竞争的线程不会阻塞，提高了相应速度
    - 缺点： 竞争的线程一直抢不到锁，自旋消耗cpu
    - 场景： 追求相应时间，同步块执行速度很快
    - 锁升级：偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁争用的时候，偏向锁就会升级为轻量级锁
    - 为什么引入
       轻量级锁考虑的是竞争锁对象的线程不多，而且线程持有锁的时间也不长的情景。
       因为阻塞线程需要CPU从用户态转到内核态，代价较大，如果刚刚阻塞不久这个锁就被释放了，那这个代价就有点得不偿失了，因此这个时候就干脆不阻塞这个线程，让它自旋这等待锁释放。
- 重量级锁
    - 优点：线程竞争不使用自旋，不占用cpu
    - 缺点：线程阻塞，相应速度慢
    - 场景：同步块执行时间比较长

- 锁升级过程： 自己画有流程图
    - 概念：
       Mark-Word：jvm里对象头数据里分为几个部分，其中，Mark-Word里默认存储对象的HashCode、分代年龄和锁标记位(锁标记位有两部分组成：1)是否是偏向锁，2）锁标志位)
       Lock-Record：线程的栈帧中建立的锁记录空间 = Displaced-Mark-Word + owner
       Displaced-Mark-Word：，用于存储锁对象目前的Mark-Word的拷贝
       owner： 指向对象头里的mark-word；
    - 加锁过程
      - 1.在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），
         虚拟机首先将在当前线程里建立Lock-Record区。
      - 2.copy对象头中的Mark-Word到Lock-Record中；
      - 3.CAS操作尝试将对象头的Mark-Word更新为指向Lock-Record的指针，并将Lock-record里的owner指针指向对象头的mark-word。
         - 步骤3成功，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，即表示此对象处于轻量级锁定状态。
         - 步骤3失败，虚拟机首先会检查对象的Mark-Word是否指向当前线程的栈帧，
           - 是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。
           - 不是说明多个线程竞争锁，轻量级锁就要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。 


### AQS  自旋锁、互斥锁、读锁写锁、条件产量、信号量、栅栏都是AQS的衍生物
- AbstractQuenedSynchronizer
    抽象的队列式同步器。它的定位是为Java中几乎所有的锁和同步器提供一个基础框架
- AQS的核心思想
    如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。
    如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，
- 工作流程
    用volatile修饰共享变量state，线程通过CAS去改变状态符，成功则获取锁成功，失败则进入等待队列，等待被唤醒。
    AQS是自旋锁：在等待唤醒的时候，经常会使用自旋（while(!cas())）的方式，不停地尝试获取锁，直到被其他线程获取成功

- 组成部分
    - CLH（三人名）队列
        是一个虚拟的双向队列，FIFO，虚拟的双向队列即不存在队列实例，仅存在节点之间的关联关系。
        AQS是将每一条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node），来实现锁的分配。
    - 状态变量(int) 用法
        - 互斥锁
          当AQS只实现为互斥锁的时候，每次只要原子更新state的值从0变为1成功了就获取了锁，可重入是通过不断把state原子更新加1实现的。
        - 互斥锁 + 共享锁
          实现为互斥锁+共享锁时: 低16位存储互斥锁的状态，高16位存储共享锁的状态，主要用于实现读写锁。
          互斥锁是一种独占锁，每次只允许一个线程独占，且当一个线程独占时，其它线程将无法再获取互斥锁及共享锁，但是它自己可以获取共享锁。
          共享锁同时允许多个线程占有，只要有一个线程占有了共享锁，所有线程（包括自己）都将无法再获取互斥锁，但是可以获取共享锁。
    - condition队列
        - 背景：
           AQS中还有另一个非常重要的内部类ConditionObject，它实现了Condition接口，主要用于实现条件锁。
        - 队列定义：
           ConditionObject中也维护了一个队列，这个队列主要用于等待条件的成立，当条件成立时，
           其它线程将signal这个队列中的元素，将其移动到AQS的队列中，等待占有锁的线程释放锁后被唤醒
        - 典型的运用场景
          BlockingQueue中的实现，当队列为空时，获取元素的线程阻塞在notEmpty条件上，
          一旦队列中添加了一个元素，将通知notEmpty条件，将其队列中的元素移动到AQS队列中等待被唤醒

- AQS设计模式    AQS是抽象类，使用了模板方法设计模式，
   - 模板方法有：
       获取互斥锁方法(可中断方法)，，获取共享锁方法(可中断方法)， 释放互斥锁，释放共享锁；
   - 需要子类选择实现的方法：
       尝试获取锁(在互斥和共享下)， 尝试释放锁(在互斥和共享下), 锁是否独占(isHeldExclusively)


###  Semaphore, CountDownLatch, cyclicBarrier
- Semaphore
    资源控制，最多允许多少线程同时访问
    
- CountDownLatch 
   - 使用场景
      1. 类似springboot 等待多组件启动成功后才开始启动， 主线程await，自线程countDown
      2. 类似赛跑，所有自线程先await(), 等待主线程countDown，
   - 缺点： 一次性的，用完就不能再用了
   
- cyclicBarrie
   - 构造方法
      默认：CyclicBarrier(int parties)
      高级：CyclicBarrier(int parties, Runnable barrierAction)，用于在线程到达屏障时，优先执行barrierAction，方便处理更复杂的业务场景
   - 使用场景
      和CountDownLatch类似：在一组线程全部都到达屏障后，屏障才会开门，让await的线程干活。
   - 区别
      CountDownLatch：重点是“一个线程（多个线程）等待”，而其他的N个线程在完成“某件事情”之后，可以终止，也可以等待。
      CyclicBarrier： 重点是多个线程，在任意一个线程没有完成，所有的线程都必须等待。












