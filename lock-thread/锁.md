### sync,lock区别
- 1.一个接口，一个关键字，
    synchronized是内置的语言实现，lock是jdk实现；
- 2.死锁:
    synchronized异常时候会自动释放不会出现死锁；lock异常时候，不主动释放，必须手动unlock来释放锁，否则引起死锁。 
- 3.效率
     Lock可以通过读写锁实现读写分离，提高效率 
- 4.lock.interrupt(); lock.tryLock();
    synchronized不能响应中断；不能判断是否有锁，只能等待；
    
### lock接口
- 三顶级接口
    lock接口，readwriteLock接口，condition接口
- 读写锁，
    只有读读是可以并行的，读写，写写都是串行的，需要获取同一把锁，会竞争
    适用于读多写少的高并发场景
- lockInterruptibly()
    可以相应中断，打断尝试获取锁但失败等待的线程，
    不能打断正在运行的线程。
- 释放锁，
    在finally中释放，防止异常条件下走不到释放语句。
- 线程释放锁的几种情形：
    执行完任务；遇到异常；wait方法
- wait()方法和notify()方法在放弃对象监视器的时候的区别：
     wait()方法立即释放对象监视器
     notify()方法则会等待线程剩余代码执行完毕才会放弃对象监视器。
     
### 多线程释放同步锁
- 1.执行完同步代码块。
- 2.遇到异常而导致线程终止。
- 3.wait()方法，这个线程会释放锁，进行对象的等待池。

- 不会释放锁的情况：
    - 1.Thread.sleep()方法，当前线程放弃CPU，开始睡眠，在睡眠中不会释放锁。
    - 2.Thread.yield()方法，当前线程放弃CPU，但不会释放锁。
    - 3.在执行同步代码块的过程中，其他线程执行了当前对象的suspend()方法，当前线程被暂停，但不会释放锁。但Thread类的suspend()方法已经被废弃。
  
### 并发编程3要素
- 原子性：可见性：有序性：
     
- volatile 保证可见性(内存屏障)和有序性(禁止指令重排序)，但不保证原子性
  synchronized 保证原子性，有序性，可见性
       
### CAS  高效原子操作，由硬件保证
- 三大问题 
   - ABA问题，
       解决思路：使用版本号,在变量前面追加上版本号
       jdk1.5引入AtomicStampedReference来解决ABA问题
   - 循环时间长开销大
       并发量比较高的情况下，CAS如果长时间不成功，会给CPU带来非常大的执行开销
   - 只能保证一个共享变量的原子操作
      用锁，或者把多个共享变量合并成一个共享变量
      jdk1.5后引入AtomicReference类，可以把多变量放到这个类中
      
### 锁分类
- 悲观锁，
- 乐观锁，
   乐观锁的实现方式与悲观锁不同之处就在于乐观锁可以对竞争失败了的线程进行其他策略的处理，而悲观锁只能等待锁释放
- 自旋锁
    - 定义：当前线程不停地执行循环体，不进行线程状态的改变，所以响应速度更快
    - 使用场景：线程竞争不激烈，并且保持锁的时间段。   
- 偏向锁
- CAS锁

### 对象在内存中的布局(看对应的plantUml)
- 对象头信息是与对象自身定义的数据无关的额外存储成本，但是考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构；
   在极小的空间内存存储尽量多的数据，它会根据对象的状态复用自己的存储空间，即Mark Word会随着程序的运行发生变化：
   1. 正常-> 偏向锁时， 会把hashcode转而存储线程id，并且把1bit的是否偏向锁置为1;(偏向锁是通过比较线程id是否相同)
   2. 偏向锁-> 轻量级锁时，mark-word中的 hashcode，GC分代年龄，1bit的是否偏向锁会被覆盖，转而存储指向栈中lock-record的指针；
   3. 轻量级锁-> 重量级锁时， 这个指向lock-record的指针转为指向monitor对象的的指针
   
### [synchronized底层实现原理](https://www.cnblogs.com/aspirant/p/11470858.html)
- synchronized是一种对象锁（锁的是对象而非引用变量），作用粒度是对象,用来实现对临界资源的同步互斥访问，是可重入的。其可重入最大的作用是避免死锁
- Synchronized的语义底层是通过一个monitor的对象来完成，其实wait/notify等方法也依赖于monitor对象，
    这就是为什么只有在同步的块或者方法中才能调用wait/notify等方法
- Synchronized在JVM里的实现都是基于进入和退出Monitor对象来实现方法同步和代码块同步，虽然具体实现细节不一样，但是都可以通过成对的MonitorEnter和MonitorExit指令来实现。 
     MonitorEnter指令：插入在同步代码块的开始位置，当代码执行到该指令时，将会尝试获取该对象Monitor的所有权，即尝试获得该对象的锁；
     MonitorExit指令：插入在方法结束处和异常处，JVM保证每个MonitorEnter必须有对应的MonitorExit；
- monitor的实现和逻辑
    1. 在java虚拟机中，monitor是由ObjectMonitor实现的
    2. ObjectMonitor中有两个队列，_WaitSet 和 _EntryList，用来保存ObjectWaiter对象列表（ 每个等待锁的线程都会被封装成ObjectWaiter对象 ）
    3. 当多个线程同时访问一段同步代码时：
      3.1 首先会进入 _EntryList 集合，当线程获取到对象的monitor后，进入ObjectMonitor并把owner变量(cas方式)设置为当前线程，同时monitor中的计数器count加1；
      3.2 若线程调用 wait() 方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入 WaitSet集合中等待被唤醒；
      3.3 若当前线程执行完毕，也将释放monitor（锁）并复位count的值，以便其他线程进入获取monitor(锁)；
      3.4 当进行线程竞争时， _EntryList和WaitSet中的线程都会进行竞争。
- 为什么叫重量级锁：
      Synchronized是通过对象内部的一个叫做 监视器锁（Monitor）来实现的。但是监视器锁本质又是依赖于底层的操作系统
      的Mutex Lock来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，所以叫重量级锁
### 锁升级
无锁---> 偏向锁------> 自旋锁(轻量级锁) ------> 重量级锁
- 偏向锁
    - 优点： 加解锁不需要额外消耗，执行同步和异步方法是纳秒级差距
    - 缺点： 如果线程间存在锁竞争，有锁撤销的消耗
    - 场景： 一个线程访问同步块
    - 为什么引入
      因为经过研究发现，大多数时候是不存在锁竞争的，常常是一个线程多次获得同一个锁，因此如果每次都要竞争锁会增大很多没有必要付出的代价，为了降低获取锁的代价，才引入的偏向锁。
- 自旋锁
    - 优点： 竞争的线程不会阻塞，提高了相应速度
    - 缺点： 竞争的线程一直抢不到锁，自旋消耗cpu
    - 场景： 追求相应时间，同步块执行速度很快
    - 锁升级：偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁争用的时候，偏向锁就会升级为轻量级锁
    - 为什么引入
       轻量级锁考虑的是竞争锁对象的线程不多，而且线程持有锁的时间也不长的情景。
       因为阻塞线程需要CPU从用户态转到内核态，代价较大，如果刚刚阻塞不久这个锁就被释放了，那这个代价就有点得不偿失了，因此这个时候就干脆不阻塞这个线程，让它自旋这等待锁释放。
- 重量级锁
    - 优点：线程竞争不使用自旋，不占用cpu
    - 缺点：线程阻塞，相应速度慢
    - 场景：同步块执行时间比较长

- 锁升级过程： 自己画有流程图
    - 概念：
       Mark-Word：jvm里对象头数据里分为几个部分，其中，Mark-Word里默认存储对象的HashCode、分代年龄和锁标记位(锁标记位有两部分组成：1)是否是偏向锁，2）锁标志位)
       Lock-Record：线程的栈帧中建立的私有锁记录空间 = Displaced-Mark-Word + owner
       Displaced-Mark-Word：，用于存储锁对象目前的Mark-Word的拷贝
       owner： 指向持有ObejctMonitor的线程id；
    - 加锁过程
      - 1.在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），
         虚拟机首先将在当前线程里建立Lock-Record区。
      - 2.copy对象头中的Mark-Word到Lock-Record中；
      - 3.CAS操作尝试将对象头的Mark-Word更新为指向Lock-Record的指针，并将Lock-record里的owner指针指向对象头的mark-word。
         - 步骤3成功，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，即表示此对象处于轻量级锁定状态。
         - 步骤3失败，虚拟机首先会检查对象的Mark-Word是否指向当前线程的栈帧，
           - 是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。
           - 不是说明多个线程竞争锁，轻量级锁就要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。 


### AQS  自旋锁、互斥锁、读锁写锁、条件产量、信号量、栅栏都是AQS的衍生物
- AbstractQuenedSynchronizer
    抽象的队列式同步器。它的定位是为Java中几乎所有的锁和同步器提供一个基础框架
- AQS的核心思想
    如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。
    如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，
- 工作流程
    用volatile修饰共享变量state，线程通过CAS去改变状态符，成功则获取锁成功，失败则进入等待队列，等待被唤醒。
    AQS是自旋锁：在等待唤醒的时候，经常会使用自旋（while(!cas())）的方式，不停地尝试获取锁，直到被其他线程获取成功

- 组成部分
    - CLH（三人名）队列
        是一个虚拟的双向队列，FIFO，虚拟的双向队列即不存在队列实例，仅存在节点之间的关联关系。
        AQS是将每一条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node），来实现锁的分配。
    - 状态变量(int) 用法
        - 互斥锁
          当AQS只实现为互斥锁的时候，每次只要原子更新state的值从0变为1成功了就获取了锁，可重入是通过不断把state原子更新加1实现的。
        - 互斥锁 + 共享锁
          实现为互斥锁+共享锁时: 低16位存储互斥锁的状态，高16位存储共享锁的状态，主要用于实现读写锁。
          互斥锁是一种独占锁，每次只允许一个线程独占，且当一个线程独占时，其它线程将无法再获取互斥锁及共享锁，但是它自己可以获取共享锁。
          共享锁同时允许多个线程占有，只要有一个线程占有了共享锁，所有线程（包括自己）都将无法再获取互斥锁，但是可以获取共享锁。
    - condition队列
        - 背景：
           AQS中还有另一个非常重要的内部类ConditionObject，它实现了Condition接口，主要用于实现条件锁。
        - 队列定义：
           ConditionObject中也维护了一个队列，这个队列主要用于等待条件的成立，当条件成立时，
           其它线程将signal这个队列中的元素，将其移动到AQS的队列中，等待占有锁的线程释放锁后被唤醒
        - 典型的运用场景
          BlockingQueue中的实现，当队列为空时，获取元素的线程阻塞在notEmpty条件上，
          一旦队列中添加了一个元素，将通知notEmpty条件，将其队列中的元素移动到AQS队列中等待被唤醒

- AQS设计模式    AQS是抽象类，使用了模板方法设计模式，
   - 模板方法有：
       获取互斥锁方法(可中断方法)，，获取共享锁方法(可中断方法)， 释放互斥锁，释放共享锁；
   - 需要子类选择实现的方法：
       尝试获取锁(在互斥和共享下)， 尝试释放锁(在互斥和共享下), 锁是否独占(isHeldExclusively)


###  Semaphore, CountDownLatch, cyclicBarrier
- Semaphore
    资源控制，最多允许多少线程同时访问
    
- CountDownLatch 
   - 使用场景
      1. 类似springboot 等待多组件启动成功后才开始启动， 主线程await，自线程countDown
      2. 类似赛跑，所有自线程先await(), 等待主线程countDown，
   - 缺点： 一次性的，用完就不能再用了
   
- cyclicBarrie
   - 构造方法
      默认：CyclicBarrier(int parties)
      高级：CyclicBarrier(int parties, Runnable barrierAction)，用于在线程到达屏障时，优先执行barrierAction，方便处理更复杂的业务场景
   - 使用场景
      和CountDownLatch类似：在一组线程全部都到达屏障后，屏障才会开门，让await的线程干活。
   - 区别
      CountDownLatch：重点是“一个线程（多个线程）等待”，而其他的N个线程在完成“某件事情”之后，可以终止，也可以等待。
      CyclicBarrier： 重点是多个线程，在任意一个线程没有完成，所有的线程都必须等待。



### stampedLock 
- 介绍
   1. StampedLock是为了优化可重入读写锁性能的一个锁实现工具，jdk8开始引入
   2. 相比于普通的ReentranReadWriteLock主要多了一种乐观读的功能
   3. 在API上增加了stamp的入参和返回值
   4. 不支持重入
- 为什么引入
   synchronized不可中断等，ReentrantLock未能读写分离实现，ReentrantReadWriteLock能够读写分离了，
   但是对于其写锁想要获取的话，就必须没有任何其他读写锁存在才可以，这实现了悲观读取。
   而且如果读操作很多，写很少的情况下，线程有可能遭遇饥饿问题。
- 三种模式： StampedLock lock = new StampedLock();
   （1）写入：lock.writeLock()，返回stamp。是一个独占锁，也是一个悲观锁。 lock.unlockWirte(stamp);
   （2）读取：lock.readLock(), 返回stamp。这时候是一个悲观锁。lock.unlockRead(stamp).
   （3）乐观读取：lock.tryOptimisticRead()方法返回一个long型stamp，只有当前同步状态没有被写模式所占有是才能获取到。
     乐观读取模式仅用于短时间读取操作时经常能够降低竞争和提高吞吐量。
    
- 乐观读
1.乐观读并不是一种锁，所以请不要和悲观读联系在一起，它是一种无锁机制，相当于java的原子类操作，
当乐观读读取了成员变量的时候，需要将变量赋值给局部变量，然后再判断程序运行期间是否存在写锁，如果存在，升级为悲观读。 
2. 使用场景：读多写少的情况;






