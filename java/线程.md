### 线程池的实现类 ThreadPoolExecutor构造函数参数
- corePoolSize ：
    核心线程数即一直保留在线程池中的线程数量，即使处于闲置状态也不会被销毁。 allowCoreThreadTimeOut为true销毁核心线程
- maximumPoolSize：
    线程池中允许存在的最大线程数
- keepAliveTime ：
    非核心线程允许的最大闲置时间，超过这个时间就会本地销毁。
- workQueue：用来存放任务的队列。
    - SynchronousQueue：
        没有容量，是无缓冲等待队列的阻塞队列，直接将任务交给消费者线程;阻塞时直接拒绝策略(一般要求maximumPoolSizes为无界)
        拥有公平（FIFO）和非公平(LIFO)策略
    - LinkedBlockingQueue：
        这个队列是一个无界队列。如果线程池中的线程数等于corePoolSize将任务放入队列中等待，由于队列大小没有限制所以也被称为无界队列。
        当使用这个队列的时候maximumPoolSizes不生效（线程池中线程的数量不会超过corePoolSize），所以一般都会设置为0。
    - ArrayBlockingQueue：
        可以设置队列的最大容量的有界队列。当线程池中线程数大于或者等于 maximumPoolSizes 的时候，就会把任务放到这个队列中，
        当前队列中的任务大于队列的最大容量就会丢弃掉该任务交由 RejectedExecutionHandler 处理。
         - 4种拒绝策略：
           1. 丢弃任务并抛异常(默认)
           2. 丢弃任务不抛异常
           3. 丢弃队列最前面的任务，重新提交
           4. 由提交任务的线程执行该任务。
        
        
- 线程执行失败
1. 如果是Future f = poll.submit(runnable), 在future里进行catch处理就可以了。
2. 使用execute()时：
   1. 把runnable用try-catch包起来。不太好，异常处理丑陋，增加代码量。
   2. 自定义线程池，继承ThreadPoolExecutor并复写其afterExecute(Runnable r, Throwable t)方法。
   3. (默认实现打印异常)实现Thread.UncaughtExceptionHandler接口和接口中的方法uncaughtException(Thread t, Throwable e)
      并将该handler传递给线程池的参数：ThreadFactory(threadFactory.newThread(Runnable r))。
        
- 如何确定线程池中线程的个数
1.任务的性质：CPU密集型任务(cpu个数+1)
           IO密集型任务(因为不占用cpu，所以可以加大。2*cpu个数+1)
           
### 定時线程池 ScheduledThreadPoolExecutor 实现
1. schedule(Runnable command,long delay,TimeUnit unit)
  将放入的任务增加一个delay延迟字段，然后使它被取出时，等待delay这么长就行
2. 使用了一个延时队列DelayQueue，每次poll时总是把最小delay的任务取出来；
        
### 如何控制线程池线程的优先级
1. 简单的，传入任务时，同时设置该线程的优先级();
2. 使用ThreadPoolExecutor实现一个带优先级的线程池:
    使用PriorityBlockingQueue优先级队列.(PriorityBlockingQueue的坑：如果优先级相同,不能确定顺序；需要自定义一个)
    
###  线程池有五种运行状态
1. RUNNING
2. SHUTDOWN(不接收新任务， 正常处理已有任务)
   调用线程池的shutdown()接口时，线程池由RUNNING -> SHUTDOWN。
3. STOP(不接收新任务， 不正常处理已有任务，中断正在处理的任务)
   调用线程池的shutdownNow()接口时，线程池由(RUNNING or SHUTDOWN ) -> STOP。
4. tidying
    当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为TIDYING状态。
    当线程池变为TIDYING状态时，会执行钩子函数terminated()。
状态切换：当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也为空时，
    就会由 SHUTDOWN -> TIDYING。 当线程池在STOP状态下，线程池中执行的任务为空时，就会由STOP -> TIDYING。
5. TERMINATED(线程池彻底终止)
    线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING -> TERMINATED。

### InterruptedException
- 当阻塞方法收到中断请求的时候就会抛出InterruptedException异常
     1. wait/sleep导致的阻塞
     2. 没有抢到锁导致的阻塞
- interrupt()方法并不能立即中断线程，该方法仅仅告诉线程外部已经有中断请求，至于是否中断还取决于线程自己
     0. 线程内部有个一个boolean类型的标志，此标志意思是当前的请求是否请求中断(默认为false)
     1. 阻塞方法收到中断请求，抛出InterruptedException，同时它会将线程B的是否请求中断标志置为false
     2. 非阻塞方法收到中断请求, 不会抛出InterruptedException，静态方法它检测完以后会自动的将是否请求中断标志位置为false


### 线程间通信， 一个线程需要等待另一个线程
1. 同步阻塞的方式：
     1. 使用condition通信，await/signal方法
     2. 使用countdownLatch.
2. 异步方式
     1. 使用completableFuture

### [CompletableFuture](https://www.jianshu.com/p/b3c4dd85901e)
1. 为什么要用这个
       1. 处理非阻塞调用的传统方法是使用事件处理器，程序员为任务完成之后要出现的动作注册一个处理器。
            但是，要尝试在一组事件处理器中实现一个控制流会很困难。
       2. 利用CompletableFuture，可以指定希望做什么，以及希望以什么顺序执行这些工作。
            这些动作不会立即发生，不过重要的是将所有代码放在一起。
2. 对于阻塞或者轮询方式，依然可以通过CompletableFuture类的CompletionStage和Future接口方式支持。
       CompletionStage接口实际上提供了同步或异步运行计算的舞台，
       通过实现多个CompletionStage命令，并且将这些命令串联在一起的方式实现多个命令之间的触发。
3. 每一种方法的两种形式
       1. 同步方法由当前线程或调用线程执行
       2. 异步方法
            不带executor的异步方法使用asyncPool来执行
            另一种异步方法使用executor执行
4. 创建CompletableFuture
       1. CompletableFuture<U> supplyAsync(Supplier<U> supplier)
       2. CompletableFuture<Void> runAsync(Runnable runnable)
5. 中间组合操作
     5.1  CompletableFuture<Void> thenRun(Runnable action)               纯消费
     5.2  CompletableFuture<Void> thenAccept(Consumer<? super T> action)  纯消费
     5.3  CompletableFuture<U> thenApply(
                 Function<? super T,? extends U> fn)
     5.4 CompletableFuture<V> thenCombine(
                 CompletionStage<? extends U> other,
                 BiFunction<? super T,? super U,? extends V> fn)
     5.5 CompletableFuture<U> thenCompose(
                 Function<? super T, ? extends CompletionStage<U>> fn)


