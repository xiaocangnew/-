
[spring中的九中设计模式](http://ju.outofmemory.cn/entry/78206)

### 在自己代码中看到的设计模式有：
- 单例模式，
- 工厂方法： 构造thrift类，构造TradeContext;
- 监听器模式: ruleSetListener-实现坚挺接口即可
- 模板方法模式: 资产计算,
- 代理模式： OrderEntryHandler使用(多个不同的handler)
- 适配器模式。
- 责任链模式： preTrade使用的就是责任链模式



### 单例模式 : 无状态，多线程并发调用ok；

- 双重检查
``````
 private volatile static Singleton uniqueInstance;
 
    private Singleton() {
    }
 
    public static Singleton getUniqueInstance() {
        if (uniqueInstance == null) {
            synchronized (Singleton.class) {
                if (uniqueInstance == null) {
                    uniqueInstance = new Singleton();
                }
            }
        }
        return uniqueInstance;
    }
``````

- [静态内部类](http://blog.csdn.net/hikvision_java_gyh/article/details/56844078)
  内部类SingletonHolder只有在第一次被使用的时候才被会装载。
``````
public class SingletonIniti {
        private SingletonIniti() {
        }
        private static class SingletonHolder {
                private static final SingletonIniti INSTANCE = newSingletonIniti();
         }
        public static SingletonIniti getInstance() {
                return SingletonHolder.INSTANCE;
        }
}
``````
- 枚举类实现。 由JVM来保证初始化一次
``````
public enum DataSourceEnum {
    DATASOURCE;
    private DBConnection connection = null;
    private DataSourceEnum() {
        connection = new DBConnection();
    }
    public DBConnection getConnection() {
        return connection;
    }
}  
``````

2.监听器模式：
1.观察者实现一个监听方法    onObserve()
2.观察者实例注册到被观察者身上。  被观察者.list;  
3.被观察者发生事件时，主动调用onObserve()方法，通知观察者。


### 模板方法模式：
 一般使用一个抽象类，制定流程，子类只需要实现其中的方法就好了。


4.代理模式：
1，  代理类实现 invokeHandler接口，复写invoke方法（里面包含被代理的接口引用），并加上代理者想要的逻辑。          
2.     (myclass)Proxy.newProxyInstance(classloader,interface,invokeHandler);



5.适配器模式   http://blog.csdn.net/zxt0601/article/details/52848004
1.类适配器模式：    class  adapter extend source implements destination
2.对象适配器模式：  包含一个目标的引用
3.接口适配器模式：  一个抽象类（空方法）实现了interface中的全部方法，我们继承抽象类，实现自己感兴趣的方法。  
注意：
 将一个Advisor适配成MethodInterceptor，MethodInterceptor才是充电头，对外提供服务的。
http://zuiyanwangyue.iteye.com/blog/348286
http://blog.csdn.net/w1033162186/article/details/50635348

### 装饰器模式：
https://www.cnblogs.com/coffeeSS/p/5405787.html


### 代理模式，适配器模式，装饰模式的区别 https://www.cnblogs.com/yzjT-mac/p/6227288.html
1.代理模式：用于控制对象访问，其原始对象用户无法得知
2.适配器模式：用于适配器模式是因为新旧接口不一致导致出现了客户端无法得到满足的问题，但是，由于旧的接口是不能被完全重构掉的，因为我们还想使用实现了这个接口的一些服务
3，装饰模式：为原来类增加一些附加功能。（继承也可以实现附加功能）



### 代理模式与责任链耦合


### [监听器模式与观察者模式](https://www.cnblogs.com/learnhow/p/5959561.html)
- 区别：
Observable和Observer属于对象驱动或值驱动。例如进度条的例子，UI界面需要时刻观察后台进度的变化从而动态更新自己。这里的关键词是动态更新。
EventListener和EventObject属于事件驱动或方法驱动。例如按钮的例子，用户造成了某个事件，立刻触发后台程序的响应。这里的关键词是响应。
