### 面向对象建模面临的一个棘手问题是数据边界和行为边界往往不一致。
- 遵循模块化的思想，我们通过类将行为和其紧密耦合的数据封装在一起。但是在复杂的业务场景下，
  行为往往跨越多个领域对象，这样的行为如果放在某一个对象中必然会导致别的对象需要向该对象暴漏其内部状态。
  
- 面向对象发展的后来，领域建模出现两种派别之争
1.一种倾向于将跨越多个领域对象的行为建模在领域服务中。如果这种做法使用过度，
   则会导致领域对象变成只提供一堆get方法的哑对象，这种建模结果被称之为贫血模型。
2.另一种则坚定的认为方法应该属于领域对象，所以所有的业务行为仍然被放在领域对象中，
   这样导致领域对象随着支持的业务场景变多而变成上帝类，而且类内部方法的抽象层次很难一致。
   另外由于行为边界很难恰当，导致对象之间数据访问关系也比较复杂，这种建模结果被称之为充血模型。

### 服务器后端发展三个阶段：
1. UI+DataBase的两层架构，这种面向数据库的架构没有灵活性。
2. UI+Service+DataBase的多层SOA架构，这种服务+表模型的架构易使服务变得囊肿，难于维护拓展，伸缩性能差
3. DDD+SOA微服务的事件驱动的CQRS读写分离架构，应付复杂业务逻辑，以聚合模型替代数据表模型，
    以并发的事件驱动替代串联的消息驱动。真正实现以业务实体为核心的灵活拓展
    
- DDD革命性
1. 领域模型准确反映了业务语言，带有业务方法的‘充血模型’,例如一些逻辑写在Order表中。
2. 传统J2EE或Spring+Hibernate等事务性编程模型只关心数据，
     这些数据对象除了简单setter/getter方法外，没有任何业务方法，被比喻成‘失血模型’，
3. DDD最大的好处是：接触到需求第一步就是考虑领域模型，DDD让你首先考虑的是业务语言，而不是数据。
    而不是将其切割成数据和行为，然后数据用数据库实现，行为使用服务实现，最后造成需求的首肢分离。

- 将数据输送到模型中
  使用事件event
  
### [DDD实践的四层架构](https://www.cnblogs.com/panxixi/p/11792508.html)
1. User Interface为用户界面层（或表示层），负责向用户显示信息和解释用户命令。
    这里指的用户可以是另一个计算机系统，不一定是使用用户界面的人。
2. Application为应用层，定义软件要完成的任务，并且指挥表达领域概念的对象来解决问题。
  这一层所负责的工作对业务来说意义重大，也是与其它系统的应用层进行交互的必要渠道。
  应用层要尽量简单，不包含业务规则或者知识，而只为下一层中的领域对象协调任务，分配工作，使它们互相协作。
3. Domain为领域层（或模型层），负责表达业务概念，业务状态信息以及业务规则。
  尽管保存业务状态的技术细节是由基础设施层实现的，但是反映业务情况的状态是由本层控制并且使用的。
  领域层是业务软件的核心，领域模型位于这一层。 
4. Infrastructure层为基础实施层
  向其他层提供通用的技术能力：为应用层传递消息，为领域层提供持久化机制，为用户界面层绘制屏幕组件，等等。
  基础设施层还能够通过架构框架来支持四个层次间的交互模式。
  
- 在四层架构模式的实践中，对于分层的本地化定义主要为：
1. User Interface层主要是Restful消息处理，配置文件解析，等等。
2. Application层主要是多进程管理及调度，多线程管理及调度，多协程调度和状态机管理，等等。
3. Domain层主要是领域模型的实现，包括领域对象的确立，这些对象的生命周期管理及关系，领域服务的定义，领域事件的发布。
4. Infrastructure层主要是业务平台，编程框架，第三方库的封装，基础算法，等等。

### DDD实践的5层架构
- 与4层架构的区别：1和2之间多一个context层。
 算法及角色-对象映射由Context拥有。
 Context“知道”在当前用例中应该找哪个对象去充当实际的演员，然后负责把对象“cast”成场景中的相应角色

- 在典型的实现
每个用例都有其对应的一个Context对象，而用例涉及到的每个角色在对应的Context里也都有一个标识符。
Context要做的只是将角色标识符与正确的对象绑定到一起。只要触发Context里的“开场”角色，代码就会运行下去。
  
  
### DDD为什么难以落地
1. 需要一个关键的角色，领域专家。他负责问题域，和问题解决域，
 他应该通晓研发的这个产品需要解决哪些问题，专业术语，关联关系
2. DDD需要我们在领域建模花费很多的时间和精力，因为在界限上下文的划分上是非常考验架构师的业务水平。
  如果没有将业务模型很好的识别出来，那么可能很快模型就会在迭代的过程中腐败掉了。
3. 很多应用本身业务逻辑并不复杂，使用DDD的“聚合根”等概念并不划算。
  DDD的优势是能对业务规则提供良好保护，缺点是有一定的规则和复杂度，开发起来没那么快。
4. 领域驱动设计最精华的部分界限上下文，强调了模型和通用语言是针对某个上下文的,
   这样的专用模型易用但不通用，才能发挥作用并容易维护
5. 总结来说，“聚合根、实体、值对象、仓库”属于单个限界上下文的实现范畴，使用的约束比较多；
   “限界上下文”则属于架构设计范畴，是将大型复杂问题分解为若干简单问题的方法，这个肯定会用到。
   
### 概念
- 限界上下文
   1. 一个由显示边界限定的特定职责。领域模型便存在于这个边界之内。
     在边界内，每一个模型概念，包括它的属性和操作，都具有特殊的含义。
   2. 一个给定的业务领域会包含多个限界上下文，想与一个限界上下文沟通，则需要通过显示边界进行通信。
     系统通过确定的限界上下文来进行解耦，而每一个上下文内部紧密组织，职责明确，具有较高的内聚性。
   3. 限界上下文之间的映射关系
     * 合作关系（Partnership）：两个上下文紧密合作的关系，一荣俱荣，一损俱损。
     * 共享内核（Shared Kernel）：两个上下文依赖部分共享的模型。
     * 客户方-供应方开发（Customer-Supplier Development）：上下文之间有组织的上下游依赖。
     * 遵奉者（Conformist）：下游上下文只能盲目依赖上游上下文。
     * 防腐层（Anticorruption Layer）：一个上下文通过一些适配和转换与另一个上下文交互。
     * 开放主机服务（Open Host Service）：定义一种协议来让其他上下文来对本上下文进行访问。
     * 发布语言（Published Language）：通常与OHS一起使用，用于定义开放主机的协议。
     * 大泥球（Big Ball of Mud）：混杂在一起的上下文关系，边界不清晰。
     * 另谋他路（SeparateWay）：两个完全没有任何联系的上下文。
- 开发时的定义
   1. 实体
      当一个对象由其标识（而不是属性）区分时，这种对象称为实体（Entity）。
   2. 值对象
      当一个对象用于对事务进行描述而没有唯一标识时，它被称作值对象（Value Object）。
      它具有不变性、相等性和可替换性。
   3. 聚合根
      一组相关对象的集合，作为一个整体被外界访问，聚合根（Aggregate Root）是这个聚合的根节点
   4. 领域服务
      一些重要的领域行为或操作，可以归类为领域服务。它既不是实体，也不是值对象的范畴。
      当我们采用了微服务架构风格，一切领域逻辑的对外暴露均需要通过领域服务来进行
   5. 领域事件
      领域事件是对领域内发生的活动进行的建模。

### CQRS (Command Query Responsibility Segration 命令处理，查询处理)
写模型： 统一语言，显式的事务边界，复杂的业务逻辑。
读模型：专门为读优化(缓存等)，有不同的SQL如NoSQL分析，简单的类组成。
- [cqrs架构图](../picture/cqrs.jpg)
   1. Command对象
         Command对象的作用是用来封装命令数据，所以这类对象以属性为主，少量简单方法，但注意这些方法中不能包含业务逻辑。
   2. CommandExecutor
         CommandExecutor的作用是执行一个命令，对于注册的例子，我们会有一个RegisterCommandExecutor的类，它只有一个Execute方法，接受RegisterCommand参数
   3. Command Bus
         作用是将一个Command派发给相应的CommandExecutor去执行

- CQRS架构的优点
    CQ两端架构分离、相互不受束缚，各自独立设计、扩展
    C端通常结合DDD，解决复杂的业务逻辑；Q端轻量级查询，多种不同的查询视图通过订阅事件来更新
    C端通过分布式消息队列水平扩展，天然支持削峰
    EDA架构(event-driven architecture)，整个系统各个部分松耦合，可扩展性好
    架构层面做到无并发，实现Command的高吞吐
    技术架构和业务代码完全分离，程序员不用关心技术问题
    更方便的分工合作
- CQRS架构的缺点
    不是强一致性，而是面向最终一致性
    强依赖高性能可靠的分布式消息队列
    必须有强大可靠的CQRS框架，从头做起成本高、风险大
    必须结合Event Sourcing模式，否则CQ分离意义不大
    Event Sourcing模式的缺点
    一些CQRS的最佳原则提高了开发人员的门槛