### zookeeper 是什么
1."高可用" "分布式" "数据管理"与 "应用协调"  "服务框架"
2. 基于对ZAB算法，该框架能够很好地保证分布式环境中数据的一致性，是一个’分布式‘数据一致性‘解决方案。

### Zookeeper的典型应用场景
* 1.集群管理与Master选举
* 2.分布式通知/协调
* 3.数据发布与订阅（配置中心）
* 4.命名服务(Naming Service)
* 5.分布式锁
* 6.分布式队列

### 工作形式
ZooKeeper使用单一主进程Leader用于处理客户端所有事务请求，  
采用ZAB协议将服务器数状态以事务形式广播到所有Follower上；

### curator
[客户端使用](https://www.jianshu.com/p/70151fc0ef5d)

### 如何保证数据一致性
1. 顺序一致性
    来自任意特定客户端的更新都会按其发送顺序被提交。也就是说，如果一个客户端将Znode z的值更新为a，在之后的操作中，它又将z的值更新为b，则没有客户端能够在看到z的值是b之后再看到值a（如果没有其他对z的更新）。
2. 原子性
    每个更新要么成功，要么失败。这意味着如果一个更新失败，则不会有客户端会看到这个更新的结果。
3. 单一系统映像
    一个客户端无论连接到哪一台服务器，它看到的都是同样的系统视图。这意味着，如果一个客户端在同一个会话中连接到一台新的服务器，它所看到的系统状态不会比在之前服务器上所看到的更老。当一台服务器出现故障，导致它的一个客户端需要尝试连接集合体中其他的服务器时，所有滞后于故障服务器的服务器都不会接受该连接请求，除非这些服务器赶上故障服务器。
4. 持久性
    一个更新一旦成功，其结果就会持久存在并且不会被撤销。这表明更新不会受到服务器故障的影响。


### [源码分析](https://blog.csdn.net/qq_40697071/article/details/102947039)

### zookeeper如何避免脑裂
- 问题产生
   1. 假死：由于心跳超时（网络原因导致的）认为master死了，但其实master还存活着。
   2. 脑裂：由于假死会发起新的master选举，选举出一个新的master，但旧的master网络又通了，导致出现了两个master ，有的客户端连接到老的master 有的客户端链接到新的master。
- 解决方式：
   1. 假死问题：通过epoch大小来拒绝旧的leader发起的请求
   2. 脑裂：选举多于半数才能成为leader机制来防止脑裂和假死

### zookeeper的数据模型
1. ZooKeeper中数据的最小单元是ZNode（数据节点），每个ZNode上都可以保存数据，同时还是可以有子节点，以“/”分割
    每个 ZNode 由2部分组成: 1.stat状态信息； 2.data数据内容
2. 包括4中数据节点类型
     1. 永久节点/ 永久顺序节点
     2. 临时节点/ 临时顺序节点

### 权限控制
- 使用ACL 权限控制表,包括三种方式
    1. 权限模式（Scheme） 
         IP：从IP地址粒度进行权限控制
         Digest：最常用，用类似于 username:password 的权限标识来进行权限配置，便于区分不同应用来进行权限控制
         World：最开放的权限控制方式，是一种特殊的digest模式，只有一个权限标识“world:anyone”
         Super：超级用户
    2. 授权对象
        授权对象指的是权限赋予的用户或一个指定实体，例如IP地址或是机器灯。
    3. 权限
        CREATE：数据节点创建权限，允许授权对象在该Znode下创建子节点
        DELETE：子节点删除权限，允许授权对象删除该数据节点的子节点
        READ：数据节点的读取权限，允许授权对象访问该数据节点并读取其数据内容或子节点列表等
        WRITE：数据节点更新权限，允许授权对象对该数据节点进行更新操作
        ADMIN：数据节点管理权限，允许授权对象对该数据节点进行ACL相关设置操作

### 文件系统
1. 提供一个多层级的节点命名空间（节点称为znode）。
     目录节点和文件节点都可以设置关联的数据；文件系统中只有文件节点可以存放数据而目录节点不行。
2. 内存中维护了这个树状的目录结构(保证高吞吐和低延迟)
     这种特性使得Zookeeper不能用于存放大量的数据，每个节点的存放数据上限为1M。

### watcher机制
1. 客户端向服务端的某个Znode注册一个Watcher监听，服务端会向指定客户端发送一个事件通知来实现分布式的通知功能
2. watcher是一次性的，这样的设计有效的减轻了服务端的压力，不然对于更新非常频繁的节点，服务端会不断的向客户端发送事件通知，无论对于网络还是服务端的压力都非常大
3. watcher event异步发送, 只能保证客户端能够接收到，但是在不同时刻。只能保证最终一致性。
4. 客户端重新连接上后，所有先前注册过的watch，都会被重新注册。通常这是完全透明的。只有在一个特殊情况下，watch可能会丢失

### zookeeper 不提供负载均衡的策略

### 动态添加新server-node
1. 每个连接到ZK Server时，都会配置一个Connect的字符串，字符串上指定了所有ZK Server的服务器列表，
    形式类似于：“192.168.1.2:2181,192.168.1.3:2181,192.168.1.4:2181”；且配置好之后是不能变的。
2. zookeeper 在3.5版本后支持动态更新