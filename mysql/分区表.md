### 背景
一张表里面保存了上亿甚至过十亿的记录，这些表里面保存了大量的历史记录。
清理数据对数据库造成了很大压力。即使我们把这些删除了，但底层的数据文件并没有变小。
面对这类问题，最有效的方法就是在使用分区表。最常见的分区方法就是按照时间进行分区。

### 特点
1. 在逻辑上为一个表，在物理上存储在多个文件中
2. 在crud操作时，都是先锁住所有分区，然后引擎判断是否可以优化到某一个分区上，可以的化就释放锁。
3. 如果查询条件不包含partition key的话, 分区表效率和不分区一样。

### 分区方式
1. hash分区
  - 特点：
    1. 根据MOD(分区键，分区数)的值把数据行存储到表的不同分区中
    2. 数据可以平均的分布在各个分区中
    3. HASH分区的键值必须是一个INT类型的值，或是通过函数可以转为INT类型
  - 创建方式：
  建表语句后面追加：PARTITION BY HASH(customer_id) PARTITIONS 4;
2. range分区
  - 特点：
    1. 根据分区键值的范围把数据行存储到表的不同分区中
    2. 多个分区的范围要连续，但是不能重叠
    3. 默认情况下使用VALUES LESS THAN属性，即每个分区不包括指定的那个值
  - 创建方式：
    建表语句后面追加：partition by range(customer_id) (
    partition p0 values less than (10000),
    partition p0 values less than (20000),
    partition p0 values less than maxvalue
    );
3. list分区(枚举)
  - 特点：
    1. 按分区键取值的列表进行分区
    2. 同范围分区一样，各分区的列表值不能重复
    3. 每一行数据必须能找到对应的分区列表，否则数据插入失败
  - 创建方式：
      建表语句后面追加：partition by list(type) (
      partition p0 values in (1,2,3),
      partition p0 values in (4,5,6)
      );

### 操作
1. 增加分区： ALTER TABLE customer_login_log ADD PARTITION (PARTITION p3 VALUES LESS THAN(2020))
2. 删除分区：ALTER TABLE customer_login_log DROP PARTITION p0;(同时会删除分区上的数据)

### 优缺点
- 优点
A：表非常大以至于无法全部都放在内存中，或者只在表的最后部分有热点数据，其他都是历史数据
B：分区表的数据更容易维护.如：想批量删除大量数据可以使用清除整个分区的方式。另外，还可以对一个独立分区进行优化、检查、修复等操作
C：分区表的数据可以分布在不同的物理设备上，从而高效地利用多个硬件设备
D：可以使用分区表来避免某些特殊的瓶颈，如：innodb的单个索引的互斥访问，ext3文件系统的inode锁竞争等
E：如果需要，还可以备份和恢复独立的分区，这在非常大的数据集的场景下效果非常好
F：优化查询，在where字句中包含分区列时，可以只使用必要的分区来提高查询效率，同时在涉及sum()和count()这类聚合函数的查询时，可以在每个分区上面并行处理，最终只需要汇总所有分区得到的结果。

- 缺点
1. 分区字段必须是主键索引中的字段,你可以如下定义主键.这样就可以用时间字段来分区.
 PRIMARY KEY (ID,my_time)，这样是为了保证唯一性约束
A：如果分区字段中有主键或者唯一索引列，那么所有主键列和唯一索引列都必须包含进来，
B：分区表中无法使用外键约束
C：mysql数据库支持的分区类型为水平分区，并不支持垂直分区，因此，mysql数据库的分区中索引是局部分区索引，一个分区中既存放了数据又存放了索引，而全局分区是指的数据库放在各个分区中，但是所有的数据的索引放在另外一个对象中
D：目前mysql不支持空间类型和临时表类型进行分区。不支持全文索引

- 注意
mysql数据库的分区总是把null当作比任何非null更小的值，这和数据库中处理null值的order by操作是一样的，升序排序时null总是在最前面，
因此对于不同的分区类型，mysql数据库对于null的处理也各不相同：
对于range分区，如果向分区列插入了null，则mysql数据库会将该值放入最左边的分区，注意，如果删除分区，分区下的所有内容都从磁盘中删掉了，null所在分区被删除，null值也就跟着被删除了。
在list分区下要使用null，则必须显式地定义在分区的散列值中，否则插入null时会报错。
hash和key分区对于null的处理方式和range,list分区不一样，任何分区函数都会将null返回为0.

