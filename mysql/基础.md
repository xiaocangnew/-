### innodb和myIsam引擎对比（都是用b+树）
- 事务处理不同
    MyISAM是非事务安全型的，而InnoDB是事务安全型的
- 锁机制不同
    MyISAM是表级锁，而InnoDB是行级锁；
- 索引机制不同
    MyISAM使用非聚簇索引，索引和数据存储是分开的； innodb使用聚簇索引，数据文件本身就是索引文件；
- 主键
    MyISAM可以没有主键， innodb必须有(数据文件本身要按主键聚集);
- 外键支持   
    mysiam表不支持外键，而InnoDB支持


### [存储结构](https://blog.csdn.net/chenjiayi_yun/article/details/45533909)
* 从物理意义上来讲，InnoDB表空间组成：
   - 共享表空间文件（ibdata1，最大64Tb):数据库的所有的表数据，索引文件全部放在一个文件中
   - 独占表空间文（ibd，受限文件系统）: ibd文件 = 单一表数据+索引
   - 表结构文件（.frm）：保存每个数据表的元数据(meta)信息，包括表结构的定义
   - 日志文件（redo文件）

* 从系统意义上来讲，InnoDB表空间（Tablespace）: 由分散的段(Segment)组成。
   - 段(Segment)包含多个区（Extent）。
   - 区（Extent）由64个连续的页（Page）组成，
   - 页大小为16K   (数据页、Undo页、系统页、事务数据页、插入缓冲位图页、以及插入缓冲空闲列表页)
   
### [日志系统]()
- 错误日志： --log-err 默认host_name.err
- 查询日志： --log 默认名host_name.log
- 慢查询日志: -log-slow-queries  默认名host_name.-slow.log
- 二进制日志(记录数据修改)： -log-bin
   * 恢复数据
      - 使用事件时间的时间点恢复 --start-datetime  --stop-datetime
      - 使用事件位置的时间点恢复 --start-position  --stop-position
        shell> mysqlbinlog --stop-datetime="2017-04-20 9:59:59" /var/lib/mysql/mysql-bin.000001 | mysql -u root -p  
        shell> mysqlbinlog --start-datetime="2017-04-20 10:01:00" /var/lib/mysql/mysql-bin.000001 | mysql -u root -p  
      - 查询时间段内日志的执行内容
        mysqlbinlog --start-datetime='2018-01-08 02:01:00' --stop-datetime='2018-01-08 02:30:10' -d test /var/lib/mysql/mysql-bin.000170 -v (|grep DELETE -A 5)
   * 日志录入格式：
      - Statement：每一条会修改数据的sql都会记录在binlog中
      - Row:不记录sql语句上下文相关信息，仅保存哪条记录被修改。
      - Mixedlevel: 是以上两种level的混合使用
      - statement 可能占用空间会相对小一些，传送到 slave的时间可能也短，但是没有row模式的可靠
      
- 事务日志 undo-log; redo-log; undo/redo-log

* 是否启用了日志 ：show variables like 'log_%';
* 怎样知道当前的日志 ：show master status;
* 显示二进制日志数目 ： show master logs;
* 看二进制日志文件用
   shell> mysqlbinlog mail-bin.000001
   shell> mysqlbinlog mail-bin.000001 | tail
   
### 存储结构 ：使用B+树存储；
- 为什么不使用B树存储？
  - 1.因为B+树的分支结点并不会存储关键字的具体信息，只存储索引，所以相较于B树也较小；
      因此一次I/O操作所能够容纳的关键字就多一些，那么读取一个结点的I/O操作次数也就少一些；
  - 2.B+树的所有具体信息都存储在叶子结点，通常都会使用链表将叶子结点连接起来，遍历叶子结点就能够获取到所有的数据，就可以进行区间查询，
      B树只有中序遍历才能够获取到所有的数据
  - 所以，通常B+树用于数据库索引，而B树则常用于文件索引。

- 为什么不使用红黑树
  - 红黑树的阶数更大，B树更短，这样查找的时候B树更具有优势了，效率也就越高。
  - 当用红黑树的时候，一次只能得到一个键值的信息，而用B树，可以得到最多M-1个键值的信息；
    由于计算机局部性原理，B树更好
### 事务  
- 事务是如何实现的？  两阶段提交保证事务。
- 事务有ACID属性，所以就是如何保证这几个特性就可以实现事务。
   - 隔离性由锁来保证。
   - 一致性由undo-log来保证，可以做事务回滚和MVCC的功能。
   - 原子性与持久性由redo-log来保证。
- 事务的隔离级别  select @@tx_isolation 默认可重复度，有幻读问题
  * 未提交读R：有脏读问题:就是指事务T1读取了事务T2未提取的数据
  * 提交读RC：没有脏读问题; 有不可重复读问题:T1读取a-->T2修改a，然后commit--> T1再次读取a
  * 可重复读RR：没有不可重复问题; 有幻读问题:T1读取a1-a2两条记录-->T2插入a1.5，然后commit--> T1再次读取,a1-a2，这时有3条记录
  * 序列化读S：没有幻读问题

  
### [锁](http://mysql.taobao.org/monthly/2016/01/01/)

InnoDB是基于索引来完成行锁

- gap锁   
    - 间隙锁是一个在 索引记录 之间的间隙上的锁 （没有建立索引或者是非唯一索引时，则语句会产生间隙锁）
    - 当使用唯一索引来搜索唯一行的语句时，不需要间隙锁定
    
- 行级锁
  - lock_rec_not_gap ：单纯的锁在记录上
  - lock_gap ：只锁住一段范围，不锁记录本身，通常表示两个索引记录之间：可重复读RR级别下；
  - lock_ordinary(next_key lock) 包含记录本身及记录之前的GAP， 正是为了解决RR隔离级别下的幻读问题
  - lock_share： 其他事务可以读取，但不可以修改
  - lock_x(排他锁) 通常对于UPDATE或者DELETE操作，或者类似SELECT … FOR UPDATE操作，都会对记录加排他锁
  - lock_insert_intention(插入意向锁)
  - lock_predicate
  - 隐式锁
  
- 表级锁
  - LOCK_IS、
  - LOCK_IX、
  - LOCK_X、
  - LOCK_S
  - LOCK_AUTO_INC
  
  
### 索引
- 索引分类
    - 聚簇索引： 使用B+树， 非叶子节点为主键id， 叶子节点为数据；
    - 非聚簇索引： 使用B+树， 非叶子节点为索引列， 叶子节点为主键id；
- 索引优化
    * 常见优化方向
       - 设计时注意：
          1. 最左前缀匹配原则
          2. 尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)/count(*)，
          3. 索引要建立在经常进行select操作的字段上
       - 不走索引的情况
          1. 索引列参与运算
          2. 索引列使用了函数
          3. where中or操作时，部分列没有建索引
          4. where中模糊搜索like时，'%abc'不走索引，'abc%'走索引
          5. where中使用!=或<>操作符
       - sql优化
          1. 避免使用select *, 使用具体字段；
          2. 避免使用in 和 not in，or， null值判断；
    * explain--常见的select type， type， extra
         - id:操作的顺序。数字越大越先执行；id相同则顺序执行。id列为null的就表是这是一个结果集
         - select_type：查询中每个 select 子句的类型。
            A：simple：表示不需要union操作或者不包含子查询的简单select查询。有连接查询时，外层的查询为simple，可以有多个
            B：primary：一个需要union操作或者含有子查询的select，位于最外层的单位查询的select_type即为primary。且只有一个
            C：union：union连接的两个select查询，第一个查询是dervied派生表，除了第一个表外，第二个以后的表select_type都是union
            D：dependent union：与union一样，出现在union 或union all语句中，但是这个查询要受到外部查询的影响
            E：union result：包含union的结果集，在union和union all语句中,因为它不需要参与查询，所以id字段为null
            F：subquery：除了from字句中包含的子查询外，其他地方出现的子查询都可能是subquery
            G：dependent subquery：与dependent union类似，表示这个subquery的查询要受到外部表查询的影响
            H：derived：from字句中出现的子查询，也叫做派生表，其他数据库中可能叫做内联视图或嵌套select
         - table:通常表名(或者别名)
         - type:
            1.system：
                表中只有一行数据或者是空表，且只能用于myisam和memory表。如果是Innodb引擎表，type列在这个情况通常都是all或者index
            2.const：
               使用唯一索引或者主键，返回记录一定是1行记录的等值where条件时，通常type是const。
            3.eq_ref：
               连接几个表的查询中，驱动表只返回一行数据，且这行数据是第二个表的主键或者唯一索引，且必须为not null，唯一索引和主键是多列时，只有所有的列都用作比较时才会出现eq_ref。唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描。eq_ref可以用于使用“=” 比较的带索引的列。比较值可以为常量或一个使用在该表前面所读取的表的列的表达式。
            4.ref：
               不像eq_ref那样要求连接顺序，也没有主键和唯一索引的要求，只要使用相等条件检索时就可能出现，
               常见与辅助索引的等值查找。或者多列主键、唯一索引中，使用第一个列之外的列作为等值查找也会出现，总之，返回数据不唯一的等值查找就可能出现。非唯一性索引扫描，返回匹配某个单独值的所有行。如果使用的键仅仅匹配少量行，该联接类型是不错的。ref可以用于使用=或<=>操作符的带索引的列。
            5.fulltext：全文索引检索
               优先级很高，若全文索引和普通索引同时存在时，mysql不管代价，优先选择使用全文索引
            6.ref_or_null：
               与ref方法类似，只是增加了null值的比较。实际用的不多。
            7.unique_subquery：
                用于where中的in形式子查询，子查询返回不重复值唯一值
            8.index_subquery：
                用于in形式子查询使用到了辅助索引或者in常数列表，子查询可能返回重复值，可以使用索引将子查询去重。
            9.range：索引范围扫描，
                常见于使用>,<,is null,between ,in ,like等运算符的查询中。
            10.index_merge：
                查询使用了两个以上的索引，最后取交集或者并集，常见and ，or的条件使用了不同的索引，官方排序这个在ref_or_null之后，但是实际上由于要读取多个索引，性能可能大部分时间都不如range
            11.index：索引全表扫描，把索引从头到尾扫一遍
                常见于使用索引列就可以处理不需要读取数据文件的查询、可以使用索引排序或者分组的查询。优点是避免了排序，因为索引就是已经排序好的
            12.all：
                全表扫描数据文件，然后再在server层进行过滤返回符合要求的记录。
         - possible_keys：可能会用到的索引。
         - key:实际用到的索引。
         - key_len:用到的索引键的平均长度，单位为字节。
         - ref:表示本行被操作的对象的参照对象，可能是一个常量用 const 表示，也可能是其他表的
         - key 指向的对象，比如说驱动表的连接列。
         - rows:估计每次需要扫描的行数。
         - filtered:rows*filtered/100 表示该步骤最后得到的行数(估计值)。
         -extra:重要的补充信息。
            1.using filesort：无法利用索引完成的排序操作称为“文件排序”,内部的一个快速排序,但是很低效。
                数据源必须是来源于一个Table，如果是两张表，就会先建立一个temporary，using temporary，然后排序
            2.using index：
                出现这个说明mysql使用了覆盖索引，避免访问了表的数据行，效率不错！
            3.using join buffer（block nested loop），using join buffer（batched key accss）：5.6.x之后的版本优化关联查询的BNL，BKA特性。减少内表的循环数量以及比较顺序地扫描查询。
            4.using temporary：使用了临时表存储中间结果。
                临时表可以是内存临时表和磁盘临时表，执行计划中看不出来，需要查看status变量，used_tmp_table，used_tmp_disk_table才能看出来。
                表示查询需要优化。
                MYSQL需要创建一个临时表来存储结果，这通常发生在对不同的列集进行ORDER BY上
            5.using where：
                表示存储引擎返回的记录并不是所有的都满足查询条件，需要在server层进行过滤。
                查询条件中分为限制条件和检查条件，5.6之前，存储引擎只能根据限制条件扫描数据并返回，然后server层根据检查条件进行过滤再返回真正符合查询的数据。5.6.x之后支持ICP特性，可以把检查条件也下推到存储引擎层，不符合检查条件和限制条件的数据，直接不读取，这样就大大减少了存储引擎扫描的记录数量。extra列显示using index condition
    * profile
         用来分析sql性能的消耗分布情况，当用explain无法解决慢sql时，用profile
         - 操作
          mysql> show profiles;  查看sql语句
          mysql> show profile for query 7  排查具体sql；
    * 常见优化方向
