## 缓存问题
mybatis 有一级缓存和二级缓存  
一级缓存的作用域是sqlSession，默认开启
二级缓存的作用域是同一个namespace，默认关闭 

###一级缓存数据错误问题  
由于一级缓存是session级别的，所以如果多个线程同时使用session, session是线程不安全的  
当线程A进行了插入操作未完成，但是此时线程B进行查询并缓存了数据，这是就出现了一级缓存与数据库数据不一致的问题。


## sqlSession
为什么是线程不安全的，
由于JDBC的Connection对象本身不是线程安全的，而session中又只有一个connection，所以不是线程安全的

### sqlSessionManager
是线程安全的，是怎么保证线程安全的？  
使用一个threadLocl<sqlSession>； 通过代理sqlSessionProxy来进行数据增删查改；invoke方法 内部使用threadLocal.get()来获取session；  
使用时，使用startManagedSession() 方法来初始化threadLocal并设置session；

### spring中sqlSessionTemplate如何保证线程安全的？  
当是不同线程调用时，都是新建的sqlSession，
当相同线程有多次数据库操作时，使用的也不是一个sqlSession，而是一个dao操作一个sqlSession；
当在同一个事务中时，使用的是同一个sqlSession，类似sqlSessionManager，
invoke方法调用时，使用的是TransactionSynchronizationManager.ThreadLocal<Map<Object, Object>> resources,其中，
key=sqlSessionFactory, value=SqlSessionHolder(里面有sqlSession);

### Mybatis是否支持延迟加载？如果支持，它的实现原理是什么
Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。
它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。
当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。

###简述Mybatis的插件运行原理，以及如何编写一个插件。(分页插件)

### mybatis中的占位符
1. #{} 参数占位符
2. ${} 字符串占位符