### 异步调用坑   A异步调用B， B同步调用C时，会转成异步调用
https://blog.csdn.net/LG772EF/article/details/102805893

### Provider线程池被EXHAUSTED 
https://www.iteye.com/blog/manzhizhen-2391177
- Provider角色，`有IO线程池（默认无界）和业务处理线程池（默认200）两个线程池`

- 当Dispatcher使用all时，一旦Provider线程池被打满，由于异常处理也需要用业务线程池，
1.如果此时运气好，业务线程池有空闲线程，那么Consumer将收到Provider发送的线程池打满异常；
2.如果此时业务线程池还是满的，于是异常处理和应答步骤也没有线程可以跑，导致无法应答Consumer，
3.这也是为什么我们有时候能在Consumer看到线程池打满异常，有时候看到的确是超时异常
所以，为了减少在Provider线程池打满时整个系统雪崩的风险，建议将Dispatcher设置成message：

### 不支持分布式事务

### 超时
0.去掉重试次数，防止provider崩溃；
1.重新设置合理的超时时间                      
2.如果出现超时，通常是业务处理太慢，可在服务提供方执行：jstack PID > jstack.log 分析线程，进行调优

### 超时机制导致的雪崩连接-- 一次线上经验
https://blog.csdn.net/joeyon1985/article/details/51046605

  
### 
1.默认使用的通信框架，其他选择
2.服务调用是阻塞的吗
3.使用的是什么注册中心，还有别的选择吗
4.默认使用的什么序列化框架，还有别的吗
5.剔除失效服务器，原理
6.服务上线如何不影响旧版本
7.核心配置有哪些
8.服务注册于发现的流程图
9.集群容错怎么做
10.使用中遇到过什么问题
11.如果注册中心挂掉，发布者和订阅着还能通信吗
12.dubbo安全机制是怎么做的
13.描述一个服务从发布到被消费的详细过程