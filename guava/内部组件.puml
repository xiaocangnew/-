@startuml

class Segment<K, V> {

volatile int count;
long totalWeight;
int modCount;
int threshold;
final long maxSegmentWeight;

final LocalCache<K, V> map;
volatile AtomicReferenceArray<ReferenceEntry<K, V>> table;

final ReferenceQueue<K> keyReferenceQueue;
final ReferenceQueue<V> valueReferenceQueue;

final Queue<ReferenceEntry<K, V>> writeQueue;
final Queue<ReferenceEntry<K, V>> recencyQueue;
final Queue<ReferenceEntry<K, V>> accessQueue;

final StatsCounter statsCounter;
final AtomicInteger readCount = new AtomicInteger();  number of reads since the last write
}


interface ReferenceEntry<K, V>{

int getHash();
K getKey();

ValueReference<K, V> getValueReference();
void setValueReference(ValueReference<K, V> valueReference);
ReferenceEntry<K, V> getNext();

long getAccessTime();
void setAccessTime(long time);

ReferenceEntry<K, V> getNextInAccessQueue();
void setNextInAccessQueue(ReferenceEntry<K, V> next);
ReferenceEntry<K, V> getPreviousInAccessQueue();
void setPreviousInAccessQueue(ReferenceEntry<K, V> previous);

long getWriteTime();
void setWriteTime(long time);

ReferenceEntry<K, V> getNextInWriteQueue();
void setNextInWriteQueue(ReferenceEntry<K, V> next);
ReferenceEntry<K, V> getPreviousInWriteQueue();
void setPreviousInWriteQueue(ReferenceEntry<K, V> previous);
}

abstract class AbstractReferenceEntry<K, V> implements ReferenceEntry{
}

class StrongEntry<K, V> extends AbstractReferenceEntry{
}

class StrongAccessEntry<K, V> extends StrongEntry{
}
class StrongWriteEntry<K, V> extends StrongEntry{
}
class StrongAccessWriteEntry<K, V> extends StrongEntry{
}

class WeakEntry<K, V> extends AbstractReferenceEntry{
}

class WeakAccessEntry<K, V> extends WeakEntry{
}
class WeakWriteEntry<K, V> extends WeakEntry{
}
class WeakAccessWriteEntry<K, V> extends WeakEntry{
}

class LoadingValueReference<K, V> implements ValueReference{

}

interface ValueReference<K, V> {

final V referent;

V get();

waitForValue() throws ExecutionException;  //Waits for a value that may still be loading. can block

int getWeight();

ReferenceEntry<K, V> getEntry();

ValueReference<K, V> copyFor(ReferenceQueue<V> queue, @Nullable V value, ReferenceEntry<K, V> entry);

void notifyNewValue(@Nullable V newValue);  //Notifify pending loads that a new value was set

boolean isLoading();

boolean isActive();
}


class StrongValueReference<K, V> implements ValueReference{

}

class WeightedStrongValueReference<K, V> extends StrongValueReference{
int getWeight();
}

class SoftValueReference<K, V> implements ValueReference{

}

class WeightedSoftValueReference<K, V> extends SoftValueReference{
int getWeight();
}

class WeakValueReference<K, V> implements ValueReference{

}

class WeightedWeakValueReference<K, V> extends WeakValueReference{
int getWeight();
}


@enduml