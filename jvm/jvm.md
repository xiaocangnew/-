### jvm的组成部分
- 包含两个子系统和两个组件(类装载子系统，执行引擎子系统， 运行时数据区组件， 本地接口组件)
- 运行时数据区(jvm内存)分为5部分：
    - 程序计数器 
        当前线程所执行的’字节码的行号指示器‘，’字节码解析器‘的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令
    - 虚拟机栈
       每个方法被执行的时候都会创建一个栈帧，完整的栈帧包括局部变量表、操作数栈、动态连接信息、方法正常完成出口和异常完成信息
    - 本地方法区，
       本地方法栈则是为虚拟机使用到的Native方法服务。例如java与mysql交互，底层就是jvm调用自己的本地方法接口，JNI.
    - 堆（新生代，老生代）
       各个线程共享的内存区域
    - 方法区（方法区被称为永久代,内含运行常量池）
       各个线程共享的内存区域，它用于存储JIT即时编译器编译后的代码等数据：已被虚拟机加载的类信息、常量、静态变量。
      
### 垃圾回收算法
- 1.标记清除
    1.标记阶段首先通过根节点(GC Roots)，标记所有从根节点开始的对象，未被标记的对象就是未被引用的垃圾对象。
    2.清除阶段，清除所有未被标记的对象
    3.存活对象较多的情况下比较高效
- 2.复制算法
    1.从根集合节点进行扫描，标记出所有的存活对象，并将这些存活的对象复制到一块儿新的内存
- 3.标记整理
     先标记，后压缩，最后清除
- 4.分代收集算法
  - 在不同年代使用不同的算法，从而使用最合适的算法
     - 新生代存活率低，可以使用复制算法。   Minor GC方式，速度快、效率高的
         新生代内存按照8:1:1的比例分为一个eden区和两个survivor(survivor0,survivor1)区
     - 老年代对象存活率搞，没有额外空间对对象进行分配担保，所以只能使用标记清除或者标记整理算法。 Full GC
           
### 垃圾回收器
- 年轻代的垃圾回收器：
   - serial 单线程收集器， 单线程收集器，在进行垃圾收集时，必须暂停其他所有的工作线程
   - parNew 是serial的多线程版本，  
   - parallel-scavenge 是用在计算等吞吐量应用上的第一种选择
- 老年代的回收器
   - serial-old 是老年代的单线程收集器
   - cms(并发标记清除回收器) ： 初始标记、并发标记、重新标记、并发清除 
       以牺牲吞吐量为代价来获得最短回收停顿时间，适用于要求响应速度的应用。
       当剩余内存不能满足程序运行要求时，系统将会出现Concurrent Mode Failure，CMS临时采用Serial Old回收器进行垃圾清除，性能将会被降低。
   - parallel-old是parallel-scavenge 在老年代的中版本，他俩经常一起使用。
   - g1 垃圾收集器
      - 和前代收集器相似点：
         1.G1有类似CMS的收集动作：初始标记、并发标记、重新标记、清除、转移回收，
         2.并且也以一个串行收集器做担保机制
      - 不同点：
         1.设计原则是"首先收集尽可能多的垃圾(Garbage First)"
           1.1 不会等内存耗尽时候开始垃圾收集.而是在内部采用了启发式算法，在老年代找出具有高收集收益的分区进行收集。
           1.2 可以根据用户设置的暂停时间目标自动调整年轻代和总堆大小，暂停目标越短年轻代空间越小、总空间就越大
         2.G1采用内存分区(Region)的思路，将内存划分为一个个相等大小的内存分区，回收时则以分区为单位进行回收
         3.G1虽然也是分代收集器，但整个内存分区不存在物理上的年轻代与老年代的区别，只有逻辑上的分代概念，每个分区都可能随G1的运行在不同代之间前后切换
         4.G1的收集都是STW的，但年轻代和老年代的收集界限比较模糊，采用了混合(mixed)收集的方式
- cms垃圾回收器 详解
   - 优点：并发收集、低停顿。 
   - 缺点：
       1.CPU资源敏感。 
          CMS在收集与应用线程会同时会增加对堆内存的占用.CMS必须要在老年代堆内存用尽之前完成垃圾回收；
          否则CMS回收失败时，将触发担保机制，串行老年代收集器将会以STW的方式进行一次GC，从而造成较大停顿时间
       2.无法处理浮动垃圾（Floating Garbage），即无法收集并发运行中产生的新的垃圾。 
       3.容易产生空间碎片。为了解决这个问题，
           - +UserCmsCompactAtFullCollection（default=on）这个过程是无法并发的，所以每隔一段时间就会出现停顿时间稍长的问题。
           - +XX:CMSFullGCsBeforeCompaction，（default=0，每次Full GC时都进行碎片整理）。


### 如何判断一个对象是否可以被回收？
- 引用计数法  很难解决对象之间的循环引用问题
- 枚举根节点做可达性分析
    通过一系列名为“GC Roots”的对象作为起始点，从“GC Roots”对象开始向下搜索，
    如果一个对象到“GC Roots”没有任何引用链相连，说明此对象可以被回收。

### 哪些对象可以作为 GC Roots 的对象：
* 虚拟机栈中局部变量（也叫局部变量表）中引用的对象
* 方法区中类的静态变量、常量引用的对象
* 本地方法栈中 JNI (Native方法)引用的对象 

### 触发fullGC的条件
- 1.System.gc  
      可能触发fullGc
- 2.旧生代空间不足
      旧生代空间只有在新生代对象转入及创建大对象、大数组时才会出现不足的现象，
- 3.JDK 1.7 及以前的永久代空间不足
- 4. Minor GC时
      4.1 promotion failed：
       是在进行Minor GC时，survivor space放不下、对象只能放入旧生代，而此时旧生代也放不下造成的；
      4.2 空间分配担保机制失败
       在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间。
       如果这个条件成立，那么Minor GC可以确保是安全的。
       如果不成立，则虚拟机会查看HandlerPromotionFailure设置是否允许担保失败。
       如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小。
       如果大于，将尝试着进行一次Monitor GC，尽管这次GC是有风险的。
       如果小于，或者HandlerPromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC了。
- 5. CMS GC时出现concurrent mode failure
      - concurrent mode failure是在执行CMS GC的过程中同时有对象要放入旧生代，而此时旧生代空间不足造成的。

### jvm中对象的创建
- 流程： 类是否加载--> 内存是否规整 --> 并发问题 --> 对象设置
1.若Java堆中内存是绝对规整的，使用“指针碰撞“方式分配内存；如果不是规整的，就从空闲列表中分配，叫做”空闲列表“方式。( Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能)
2.划分内存时还需要考虑一个问题-并发，也有两种方式: CAS同步处理，或者本地线程分配缓冲(Thread Local Allocation Buffer, TLAB)。
   每个线程在 Java 堆中预先分配一小块内存,这个叫TLAB。只有当TLAB用完并分配新的TLAB时，才需要同步锁。可配置-XX:+/-UserTLAB
3.然后内存空间初始化操作
4.接着是做一些必要的对象设置(元信息、哈希码…)，
5.最后执行<init>方法。

### jvm中对象的访问定位
- Java程序需要通过JVM栈上的引用访问堆中的具体对象。对象的访问方式取决于 JVM 虚拟机的实现。访问方式有:句柄和直接指针
   - 指针：指向对象，代表一个对象在内存中的起始地址。
           优势：速度更快，节省了一次指针定位的时间开销。HotSpot 中采用的就是这种方式。
   - 句柄：可以理解为指向指针的指针，维护着对象的指针。句柄不直接指向对象，而是指向对象的指针（句柄不发生变化，指向固定内存地址），再由对象的指针指向对象的真实内存地址。
           优势：引用中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而引用本身不需要修改。
           
### jvm中类加载机制
- 概述：虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，解析和初始化，最终形成可以被虚拟机直接使用的java类型。
- 动态加载： Java类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类(像是基类)完全加载到jvm中，
           至于其他类，则在需要的时候才加载。这当然就是为了节省内存开销。
- 主要有一下四种类加载器:
    启动类加载器(Bootstrap ClassLoader)用来加载java核心类库，无法被java程序直接引用。
    扩展类加载器(extensions class loader):它用来加载Java的扩展库。\lib\ext目录
    系统类加载器（system class loader）：它根据Java应用的类路径（CLASSPATH）来加载 Java 类。通过ClassLoader.getSystemClassLoader()来获取它。
    用户自定义类加载器： 通过继承 java.lang.ClassLoader类的方式实现。
- 双亲委派模型：(目的：为了系统类的安全，类似“ java.lang.Object”这种核心类)
    如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，
    这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，
    子加载器才会尝试去加载类。
- 类加载过程
     加载(导入class文件)--> 验证--> 准备(给类中的静态变量分配内存空间) --> 解析(符号引用替换成直接引用) --> 初始化(clinit，为类的静态变量赋初值)
- 类加载方式: 
   1.隐式装载； 
   2.显示装载：
       ClassLoader.loadClass(className)，只加载和连接、不会进行初始化
       Class.forName(String name, boolean initialize,ClassLoader loader); 使用loader进行加载和连接，根据参数initialize决定是否初始化。
- clinit VS init  (在编译生成class文件时，编译器会产生两个方法加于class文件中，一个是类的初始化方法clinit, 另一个是实例的初始化方法init。)
    1.clinit指的是类构造器，主要作用是在类加载过程中的初始化阶段进行执行，执行内容包括静态变量初始化和静态块的执行。
       - 如果类中没有静态变量或静态代码块，那么clinit方法将不会被生成。
       - clinit只在类加载阶段执行一次；
    2.init指的是实例构造器，主要作用是在类实例化过程中执行，执行内容包括成员变量初始化和代码块的执行。
       - 每次实例化都执行一次；