### 参考
https://www.jianshu.com/p/2c5eebfd0e95
https://github.com/suxiongwei/springboot-zcs.rabbitmq

## 实现思路
- 框架的主要处理过程为：
  创建合适的连接与信道，从amqp client中获取消息暂存到本地缓存，从本地缓存读取消息并调用MessageListener接口的onMessage方法消费消息。
 
按照前面的分析，我们可以想象 Spring AMQP 为了实现自己的 message listener，需要哪些组件：
1.MessageListenerContainer的实现类，作为整个异步消息投递的核心类存在。
2.MessageListenerContainer管理了一个消费者线程组，需要相关线程类与线程调度类。container内部类：AsyncMessageProcessingConsumer，由Container调度，其start方法会启动线程
3.根据单一职责原则，线程类只负责异步消费者的创建与（无限循环）消息消费；
4.BlockingQueueConsumer异步消费者模型，用来管理消费行为与状态。
5.消息队列推送过来的消息需要一个本地队列缓存.
6.需要实现amqp-client的Consumer接口。BlockingQueueConsumer$InternalConsumer
7.用户的业务逻辑是在MessageListener接口中实现的,

#### 数据恢复的方式，
1.将数据写入磁盘上的一个持久化日志文件，Rabbit会在消息提交到日志文件后才发送响应。
2.消息消费后在持久化日志中标记为等待垃圾收集。
3.失败重启后重播持久化日志文件中的消息到合适的队列或者交换器上。

### 消息顺序性
- producer保证发送消息的顺序性：
1. channel内发送的消息是保证顺序性的， 自研确保channel与线程绑定。
3。继承AbstractRoutingConnectionFactory， 实现lookupkey方法，每个factory中只用一个channel。

- consumer端保证接受消息的顺序性
1.一个queue只用一个consumer消费(防止多消费者时，一个consumer消费失败，又传给别人消费)


### 集群(提高吞吐量)
- 集群元数据的同步（不通过zookeeper，通过rabbitmq命令设置）集群中的每个节点都会始终同步四种类型的内部元数据（类似索引）：
    - queues：队列名称和它的属性；（普通集群中queue及其内容仅仅存储于单个节点之上，所以一个节点的失效表现为其对应的queue不可用）
    - exchanges：交换器名称、类型和属性；
    - bingdings：一张简单的表格展示了如何将消息路由到队列；
    - vhost：为vhost内的队列、交换器和绑定提供命名空间和安全属性；
 当用户访问其中任何一个RabbitMQ节点时，通过rabbitmqctl查询到的信息都是相同的。
   场景1、客户端直接连接队列所在节点
   场景2、客户端连接的是非队列数据所在节点（路由到队列所在节点）


### 镜像队列（高可用）
将queue镜像到cluster中其他的节点之上。如果节点失效，queue能自动地切换到镜像中的另一个节点以保证服务的可用性。
在通常的用法中，针对每一个镜像队列都包含一个master和多个slave，分别对应于不同的节点。
slave会准确地按照master执行命令的顺序进行命令执行，故slave与master上维护的状态应该是相同的。
除了publish外所有动作都只会向master发送，然后由master将命令执行的结果广播给slave们，故看似从镜像队列中的消费操作实际上是在master上执行的。

- 镜像队列支持两种机制。
  - 事务机制，只有当前事务在全部镜像queue中执行之后，客户端才会收到Tx.CommitOk的消息。
  - publisher-confirm机制，向publisher进行当前message确认的前提是该message被全部镜像所接受了。

- 设置镜像：(吞吐量可能下降)
  rabbitmqctl set_policy [-p Vhost] Name Pattern Definition [Priority]
     -demo : rabbitmqctl set_policy ha-all "^rock.wechat" '{"ha-mode":"all","ha-sync-mode":"automatic"}'
     - Vhost： 可选参数，针对指定vhost下的queue进行设置
     - Name: policy的名称(自己定义)
     - Pattern: queue的匹配模式(正则表达式)
     - Definition：镜像定义，包括三个部分ha-mode, ha-params, ha-sync-mode
         ha-mode:指明镜像队列的模式，有效值为 all/exactly/nodes
         ha-params
         ha-sync-mode：automatic / manual
     - priority：可选参数，policy的优先
     

### Exchange Type
- Fanout 
    消息都会被转发到与该Exchange绑定(Binding)的所有Queue上。
- Direct 
    消息被转发到RouteKey中指定的Queue。
- Topic 
    消息被转发到所有关心RouteKey中指定Topic的Queue上，
- headers
    根据消息的header中的信息进行完全匹配

### queues 路由
- routingkey：当一个exchange上绑定好多queue时，使用routingkey路由到具体queue；  
- bindingkey： 用来绑定exchange与queues，



#### 消息超时
- 为队列设置消息TTL：（x-message-ttl 参数）。
    - RabbitMQ保证死消息不会被消费者获得，同时会尽快删除死的消费者。
      - 消息不会在消费者的缓冲区中过期。只要队列在消息过期前将消息推送给消费者，消费者就一定能处理到这条消息。
      - 重新入队的消息不刷新过期时间。（例如被取消确认或者信道关闭或拒绝并重新入队）
- 为单条消息设置TTL（expiration（3000ms））
    - 当队列消息的TTL和消息TTL都被设置，时间短的TTL设置生效。
    - 为消息设置TTL有一个问题：RabbitMQ只对处于队头的消息判断是否过期（即不会扫描队列），
      很可能队列中已存在死消息，但是队列并不知情。这会影响队列统计数据的正确性，妨碍队列及时释放资源。
    
### 队列超时   
- 设置队列超时时间（x-expires）
  - 队列未被使用定义：
     - 队列没有被重新申明
     - 没有basicGet操作发生
     - 没有Consumer连接在队列上（哪怕队列一直没有消息）
    特别的：就算一直有消息进入队列，也不算队列在被使用。
    参数控制：queue被自动删除前可以处于未使用状态的时间。

### 死信队列  可以监听死信队列，做进一步处理 
- 进入死信的三种方式
1.消息被拒绝（basic.reject or basic.nack）并且requeue=false 
2.消息TTL过期 
3.队列达到最大长度 

- 死信队列配置
  x-dead-letter-exchange: x-dead-letter-exchange
  x-dead-letter-routing-key: task_queque.fail

### 镜像队列的原理
 [镜像队列](https://blog.csdn.net/u013256816/article/details/71097186)
 
### 消息消费方式 push vs pull ：实时性，流控能力，出问题时，消息保存在哪
- push方式： 即服务器将消息push到consumer 
   - 消息保存在服务端。容易造成消息堆积。
   - 服务端需要维护每次传输状态，遇到问题需要重试
   - 非常实时
   - 服务端需要依据订阅者消费能力做流控(流转机制)
   
- pull方式：consumer自己去服务器拉取消息(spring-amqp的messageListenerContainer为pull模式)
   - 保存在消费端。获取消息方便。
   - 传输失败，不需要重试
   - 默认的端短询方式的实时性依赖于pull间隔时间，间隔越大，实时性越低，长轮询方式和push一致
   - 消费端可以根据自身消费能力决定是否pull(流转机制)

### consumer
- 主动从queue的获取消息，
- 通过订阅,被动的从Queue中消费消息

- consumer编程模型伪代码如下：
ConnectionFactory factory = new ConnectionFactory();
Connection conn = factory.newConnection();
Channel channel=conn.createChannel();
channel.basicQos(int prefetchSize, int prefetchCount, boolean global) throws IOException;
channel.basicConsume(String queue, boolean autoAck, Consumer callback) throws IOException;

- autoAck：
  是否自动ack，如果不自动ack，需要使用channel.ack、channel.nack、channel.basicReject 进行消息应答
  一旦有N个消息还没有ack，则该consumer将block掉，直到有消息ack。不设置的话就可能导致Comsumer内存溢出卡死

#### 一个consumer可以订阅多个queue;  一个queue可以被多个消费者消费(消息只消费一次)

### 多租户模式：
每一个RabbitMQ服务器都能创建虚拟消息服务器，我们称之为虚拟主机（vhost）。
每一个vhost本质上是一个mini版的RabbitMQ服务器，拥有自己的队列、交换器和绑定更重要的是，他拥有自己的权限限制
      