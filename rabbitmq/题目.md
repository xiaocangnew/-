### mq的优缺点：
在特殊场景下有其对应的好处，解耦、异步、削峰
缺点有：
1.系统可用性降低，依赖rabbitmq组件的高可用
2.系统复杂度提高，比如一致性问题、如何保证消息不被重复消费、如何保证消息可靠性传输等 

### 性能调优
[性能调优](https://www.cnblogs.com/purpleraintear/p/6033136.html)
Q：MQ 们为什么要做生产者流量控制？
A：麻烦就在于：像 Erlang 的虚拟机实现和设计上都没有阻止用户往一个进程的消息队列里扔消息，当消息的生产速度过快，超过进程的处理能力时，这些消息就堆积起来，占用越来愈多的内存，最终导致VM崩溃。』 
Q：我为什么要知道 MQ 在做生产者流量控制？
A：当你发现自家的 Producers 动辄被挂起或被阻塞时，你要知道该调 Consumer 的消费速率，还是调 Memory Threshold of MQ 。

### 流控机制  
- RabbitMQ可以对内存和磁盘使用量设置阈值，当达到阈值后，生产者将被阻塞（block），直到对应项恢复正常。
    RabbitMQ在正常情况下也可以用流控（Flow Control）机制来确保稳定性。
- RabbitMQ的流量控制机制是基于信用证(Credit)的拥塞控制机制 
    1. 消息处理进程有一个信用组{InitialCredit，MoreCreditAfter}，默认值为{200, 50}。
    2. 消息发送者A向接收者B发消息，每发一条消息，Credit数量减1，直到为0，A被block住；
    3. 对于接收者B，每接收MoreCreditAfter条消息，会向A发送一条消息，给予A MoreCreditAfter个Credit，当A的Credit>0时，A可以继续向B发送消息
- 实质: 监控每个进程的mailbox，当某个进程负载过高来不及接收消息时，这个进程的mailbox就开始堆积消息。
       当堆积到一定量时，就会阻塞住上游进程，让其不得接收新消息。从而慢慢上游进程的mailbox也开始积压消息(类似多级水库，当下游水库压力过大时，上游水库就得关闭闸门，使得自己的压力也越来越大，需要关闭更上游的水库闸门，直到关闭最最上游的闸门

### 流量控制  2.8.0+引入了一个新特性“internal flow control”。至此 RabbitMQ 有三种：
- 1.1.面向每一个连接做的流量控制。 Per-Connection Flow Control 
    - 主动阻塞（Block）那些发布消息太快的连接（Connections），无需做任何配置。
    - 如果连接被阻塞了，那么它在rabbitmqctl 控制台上会显示一个blocked的状态。
   
- 1.2.面向内存做的流量控制。 Memory-Based Flow Control
    RabbitMQ 会在启动时检测机器的物理内存数值。
    默认当MQ占用40%以上内存时，MQ会主动抛出一个内存警告并阻塞所有连接
    默认值是0.4 :[{rabbit, [{vm_memory_high_watermark, 0.4}]}].

- 1.3.面向磁盘存储做的流量控制。 Disk-Based Flow Control
  默认:剩余磁盘空间<1GB，主动阻塞所有的生产者。这个阈值也是可调的。

### rabbitmq 如何保证不丢消息
- 1.producer引入事务机制或者Confirm机制
- 2.消息队列进行消息持久化
    - 1.exchange持久化：channel.exchangeDeclare(exchangeName,"direct/topic/header/fanout",true);
    - 2.queue持久化：channel.queueDeclare(queueName,true,false,false,null);
    - 3.message持久化发送,设置BasicProperties的deliverayMode=2：
- 2.consumer不自动ack，处理完成后再ack，
- 4.引入mirrored-queue镜像队列
- 5.消息补偿机制，发送消息前入库，缺失消息后可以重发；

### 为什么不应该对所有的 message 都使用持久化机制？
1. 性能下降； 有10倍差距
2. message的持久化机制用在RabbitMQ的内置cluster方案时会出现问题
    2.1 message持久化，但queue未持久化.那么当queue的owner node出现异常后，在未重建该queue前，发往该queue的message将被阻塞；
    2. 2message持久化，但queue也持久化.那么当queue的owner node出现异常后，若无法重启的情况下，则该queue无法在其他node上重建，发消息也会阻塞；
    
### 消息积压怎么处理
- 原因
   - 消费者出问题了，所以消费慢
- 导致问题
   - 集群队列的磁盘要写满
   - 导致消息过期，丢失了 
- 1. 大量消息堆积了几个小时的处理办法   
  - 修改出问题的consumer，由于堆积大量的消息，重新上线后依然需要很长时间消费,所以需要选择其他方案；
  - 进行临时紧急扩容(需要考虑机器是否存在数据库竞争等情况，临时分发程序是否可以保证正确性，及时性)
    - 1.1 先修复consumer问题，确保能够正常消费消息；
    - 1.2 新建多个queue，临时写一个分发数据的consumer程序，消费堆压的消息，轮询写入新建的多个queue中；进行快速处理；
    - 1.3 等消费完消息后，再去掉临时程序。
- 2. 堆积的消息要过期了(丢消息)
    - 要有消息补偿机制，producer发消息前要落库，之后进行重发；
- 3. mq磁盘写满
    - 写个临时程序，进行消费(直接丢弃),等mq正常后，再进行消息重发；

### 最佳实践
1.在资管后台中，在小v资产批量还款确认时，使用落库+rabbitmq的策略，为了保证事务，因为rabbitmq是三方服务，不保证事务，所以用落库的方式保证事务，然后在用sendMqTaskHandler发送消息，在spring-rabbitmq中配置了一个消费者，去消费这些消息

2.rabbitmq一般使用异步+落库的形式，同步有问题：1，q发送成功，但落库失败，
2，在大事务中，可能已经返回成功，但还没落库

### 使用场景

 [使用场景](http://blog.csdn.net/whoamiyang/article/details/54954780)
1.异步处理
2.系统解耦（消息结偶，削峰填谷---》actor模型也可以）
3.秒杀系统

### 为什么一个普通的方法加上@RabbitListener注解就能接收消息了呢？
RabbitListenerEndpointRegistry 类是用来管理RabbitListenerEndPoint的，  
它实现了smartLiftcycle，在应用起来时自动调用container.start();
