### 性能调优
[性能调优](https://www.cnblogs.com/purpleraintear/p/6033136.html)
Q：MQ 们为什么要做生产者流量控制？
A：麻烦就在于：像 Erlang 的虚拟机实现和设计上都没有阻止用户往一个进程的消息队列里扔消息，当消息的生产速度过快，超过进程的处理能力时，这些消息就堆积起来，占用越来愈多的内存，最终导致VM崩溃。』 
Q：我为什么要知道 MQ 在做生产者流量控制？
A：当你发现自家的 Producers 动辄被挂起或被阻塞时，你要知道该调 Consumer 的消费速率，还是调 Memory Threshold of MQ 。

### 流控机制  RabbitMQ的流量控制机制是基于信用证(Credit)的拥塞控制机制
- 实质: 监控每个进程的mailbox，当某个进程负载过高来不及接收消息时，这个进程的mailbox就开始堆积消息。
       当堆积到一定量时，就会阻塞住上游进程，让其不得接收新消息。从而慢慢上游进程的mailbox也开始积压消息(类似多级水库，当下游水库压力过大时，上游水库就得关闭闸门，使得自己的压力也越来越大，需要关闭更上游的水库闸门，直到关闭最最上游的闸门

### 流量控制  2.8.0+引入了一个新特性“internal flow control”。至此 RabbitMQ 有三种：
- 1.1.面向每一个连接做的流量控制。 Per-Connection Flow Control 
    - 主动阻塞（Block）那些发布消息太快的连接（Connections），无需做任何配置。
    - 如果连接被阻塞了，那么它在rabbitmqctl 控制台上会显示一个blocked的状态。
   
- 1.2.面向存储做的流量控制。 Memory-Based Flow Control
    RabbitMQ 会在启动时检测机器的物理内存数值。
    默认当MQ占用40%以上内存时，MQ会主动抛出一个内存警告并阻塞所有连接
    默认值是0.4 :[{rabbit, [{vm_memory_high_watermark, 0.4}]}].

- 1.3.面向磁盘存储做的流量控制。 Disk-Based Flow Control
  默认:剩余磁盘空间<1GB，主动阻塞所有的生产者。这个阈值也是可调的。


### 最佳实践
1.在资管后台中，在小v资产批量还款确认时，使用落库+rabbitmq的策略，为了保证事务，因为rabbitmq是三方服务，不保证事务，所以用落库的方式保证事务，然后在用sendMqTaskHandler发送消息，在spring-rabbitmq中配置了一个消费者，去消费这些消息

2.rabbitmq一般使用异步+落库的形式，同步有问题：1，q发送成功，但落库失败，
2，在大事务中，可能已经返回成功，但还没落库

### 使用场景

 [使用场景](http://blog.csdn.net/whoamiyang/article/details/54954780)
1.异步处理
2.系统解耦（消息结偶，削峰填谷---》actor模型也可以）
3.秒杀系统

### 为什么一个普通的方法加上@RabbitListener注解就能接收消息了呢？
RabbitListenerEndpointRegistry 类是用来管理RabbitListenerEndPoint的，  
它实现了smartLiftcycle，在应用起来时自动调用container.start();
