### [比较好的文章](https://blog.csdn.net/xuzhangze/article/details/80490362)

### [3次握手和4次挥手]，这中间socket状态是什么
- 3次握手  syn=1 seq=x， ack=x+1
    2次握手，可能导致server端开启一个过期连接，浪费资源；(client 第一次请求延迟到达，client端已经放弃这个请求了，此时server端收到后确认后没3次握手就开启连接)
   客户端： syn-sent --> established(客户端第二次握手后就建立连接了)
   服务端： listen --> syn-rcvd --> established
- 4次挥手 fin=x，ack=x+1
    因为tcp是全双工模式，接收到FIN意味着没有数据发送过来了，但是还可以继续发送数据。
- 注意，tcp建立连接时，可能双方同时发送sync。发完SYN，两者的状态都变为SYN-SENT。在各自收到对方的SYN后，
   两者状态都变为SYN-REVD。接着会回复对应的ACK + SYN，这个报文在对方接收之后，两者状态一起变为ESTABLISHED。
    
- 常用的三个状态是：
   - ESTABLISHED 表示正在通信，
   - TIME_WAIT 表示主动关闭(client去server请求完毕，client主动close后，client处于time_wait)，
       - 解决办法
          通过调整内核参数和适当的设置web服务器的keep-Alive值来解决， 不是由于程序错误导致；
   - CLOSE_WAIT 表示被动关闭(client去server请求被拒绝，server主动close后，client处于close_wait)。
       - 解决办法
          关闭正在运行的程序，这个需要视业务情况而定。
          尽快的修改程序里的bug，然后测试提交到线上服务器。
          
- 为什么要有time_wait,直接关闭不可以吗？
   - 1.TCP要保证在所有可能的情况下使得所有的数据都能够被正确送达，TIME_WAIT机制能够保证所有的数据都被传输。
       - 1.TIME_WAIT机制保证最后的一个ACK能够正常传输
            - 如果主动关闭的socket不维持这种状态而是进入close状态，那么主动关闭的一方在收到被动关闭方重新发送的FIN时则响应给被动方一个RST。
              被动方收到这个RST后会认为此次回话出错了，无法完成4次挥手正确关闭。
       - 2.TIME_WAIT机制保证网络上残余的数据包被抛弃
            - 这样可以防止同一个ip:port重复建立连接时使用残余数据包
            - time_wait状态的socket在等待2MSL时间后（确认一个数据报及其响应的丢弃需要两倍的MSL。MSL(Maximum Segment Lifetime)报文最长存活时间，是一个数据报在网络中单向发出到认定丢失的时间），将会转为closed状态。
            
- 三次握手过程中可以携带数据么？
  1. 第三次握手的时候，可以携带。前两次握手不能携带数据。
  2. 如果前两次握手能够携带数据，那么一旦有人想攻击服务器，那么他只需要在第一次握手中的 SYN 报文中放大量数据，
      那么服务器势必会消耗更多的时间和内存空间去处理这些数据，增大了服务器被攻击的风险。
  3.第三次握手的时候，客户端已经处于ESTABLISHED状态，并且已经能够确认服务器的接收、发送能力正常，这个时候相对安全了
  
### 说说半连接队列和 SYN Flood 攻击的关系(TCP连接的问题)
- 三次握手前，服务端的状态从CLOSED变为LISTEN, 同时在内部创建了两个队列：半连接队列和全连接队列，即SYN队列和ACCEPT队列。
   - 半连接队列
      当客户端发送SYN到服务端，服务端收到以后回复ACK和SYN，状态由LISTEN变为SYN_RCVD，
      此时这个连接就被推入了SYN队列，也就是半连接队列。
   - 全连接队列
       当客户端返回ACK, 服务端接收后，三次握手完成。
       这个时候连接等待被具体的应用取走，在被取走之前，它会被推入另外一个 TCP 维护的队列，也就是全连接队列(Accept Queue)。
- SYN Flood 攻击原理
    SYN Flood 属于典型的 DoS/DDoS 攻击。其攻击的原理很简单，就是用客户端在短时间内伪造大量不存在的 IP 地址，
    并向服务端疯狂发送SYN。对于服务端而言，会产生两个危险的后果:
     1. 处理大量的SYN包并返回对应ACK, 势必有大量连接处于SYN_RCVD状态，从而占满整个半连接队列，无法处理正常的请求。
     2. 由于是不存在的 IP，服务端长时间收不到客户端的ACK，会导致服务端不断重发数据，直到耗尽服务端的资源。
- 如何应对 SYN Flood 攻击？
    1. 增加 SYN 连接，也就是增加半连接队列的容量。
    2. 减少 SYN + ACK 重试次数，避免大量的超时重发。
    3. 利用 SYN Cookie 技术，在服务端接收到SYN后不立即分配连接资源，而是根据这个SYN计算出一个Cookie，
    连同第二次握手回复给客户端，在客户端回复ACK的时候带上这个Cookie值，服务端验证 Cookie 合法之后才分配连接资源。
    
### tcp实现可靠传输的保证
1.检验和 
2.序列号 
3.确认应答机制（ACK） 
4.超时重传机制 
5.连接管理机制,三次握手
6.流量控制
     两台主机之间因传送速率而可能引起的丢包问，使用滑动窗口
7.拥塞控制 
     使用一个拥塞窗口
     
### tcp拥塞控制机制
- 概念
    TCP的拥塞控制机制是从端到端的角度，推测网络是否发生拥塞，如果推断网络发生拥塞，则立即将数据发送速率降下来，以便缓解网络拥塞。
- 拥塞控制
    TCP的拥塞控制采用的是窗口机制，通过调节窗口的大小实现对数据发送速率的调整。
    TCP的发送端维持一个称为拥塞窗口cwnd的变量，单位为字节，用于表示在未收到接收端确认的情况下，可以连续发送的数据字节数。
- 拥塞窗口调整：
    只要网络没有出现拥塞，就可以增大拥塞窗口，提高发送速率；一旦网络出现拥塞，拥塞窗口就减小一些，减少注入网络的数据量。
- 判断网络发生拥塞的依据是：
    发送端设置一个重传计时器RTO，对于某个已发出的数据报文段，如果在RTO计时到期后，还没有收到来自接收端的确认，则认为此时网络发生了拥塞
- 拥塞控制算法
   慢启动(采用试探的方法，逐渐增大拥塞窗口，阈值前每次翻倍)、拥塞避免(阈值后每次加1，拥塞后减半)、快速重传(每收到一个失序的数据报文段后就立即发出重复确认,及早发现)和快速恢复(发送端连续收到三个重复确认时，就将慢启动阈值减半)


    
### 说说 TCP 快速打开的原理(TFO)
- 优化后的 TCP 握手流程，也就是TCP快速打开(TCP Fast Open, 即TFO)的原理。
   优化的过程:
   1. 首轮三次握手
       首先客户端发送SYN给服务端，服务端接收到。注意哦！现在服务端不是立刻回复 SYN + ACK，而是通过计算得到一个SYN Cookie, 
       将这个Cookie放到TCP报文的Fast Open选项中，然后才给客户端返回。客户端拿到这个Cookie的值缓存下来。后面正常完成三次握手。
   2. 后面的三次握手
       在后面的三次握手中，客户端会将之前缓存的 Cookie、SYN 和HTTP请求(是的，你没看错)发送给服务端，服务端验证了Cookie的合法性，
       如果不合法直接丢弃；如果是合法的，那么就正常返回SYN + ACK。
       重点来了，现在服务端能向客户端发HTTP响应了！这是最显著的改变，三次握手还没建立，仅仅验证了Cookie的合法性，就可以返回 HTTP 响应了。
       当然，客户端的ACK还得正常传过来，不然怎么叫三次握手嘛。
- TFO 的优势
  后面的握手，在拿到客户端的Cookie并验证通过以后，可以直接返回HTTP响应，
  充分利用了1个RTT(Round-Trip Time，往返时延)的时间提前进行数据传输，积累起来还是一个比较大的优势。
  
### http1.0。http1.1。 http2
- http1.0
      每个TCP连接只能发送一个请求
- http1.1
   优点：
    - 引入了长连接，即TCP连接默认不关闭，可以被多个请求复用
    - 管道化，在同一个TCP连接里面，客户端可以同时发送多个HTTP请求，而不用等待一个个响应
    - 支持 断点续传
   缺点："队头堵塞"
    - 虽然1.1版允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。
      服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。
- http2
   - 多路复用：
      多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行
   - 服务器推送：
       服务器未经请求，主动向客户端发送资源，这叫做服务器推送

### TCP,UDP的区别
1. udp面向无连接，不需要和 TCP一样在发送数据前进行三次握手建立连接
2. UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式
3. UDP是面向报文的。对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP数据报最大长度64K（包含UDP首部），
    如果数据长度超过64K就需要在应用层手动分包，UDP无法保证包序，需要在应用层进行编号。
4. 不可靠性。没有拥塞控制，一直会以恒定的速度发送数据。在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP

### http
1.发送header中几个字段：  
Content-Type字段，表明传输类型；  
boundary字段，表明各个参数中间的分隔符 
Content-Disposition： content-type字段的进一步说明； 




### http代理
- 即使通过了重重代理，请求头都会原封不动的发给服务器，响应头也会原样被客户端收到。
- HTTP 中的 Connection，用来对 HTTP 连接(端到端的一次连接)进行说明，多个说明使用英文逗号隔开，用完就删除；
  所以，如果有多个代理的话，必须在报文转给下个节点之前删除;
  
- 互联网上，存在着大量简陋并过时的代理服务器在继续工作，它们很可能无法理解 Connection中的一些字段。
  而代理服务器在遇到不认识的 Header时，往往都会选择继续转发,例如connection:keep-alive;
  
- 显式给浏览器设置代理后，浏览器会把请求头中的 Connection 替换为 Proxy-Connetion。
  这样，对于老旧的代理，它不认识这个 Header，会继续发给服务器，服务器也不认识，代理和服务器之间不会建立持久连接（不能正确处理 Connection 的都是 HTTP/1.0 代理），服务器不返回 Keep-Alive，代理和浏览器之间也不会建立持久连接。
  而对于新代理，它可以理解 Proxy-Connetion，会用 Connection 取代无意义的 Proxy-Connection，并将其发送给服务器，以收到预期的效果
  

### 用户代理 UserAgent
同样一个地址，如果设置UserAgent与不设置两者返回的结果是不一样的，例如以下几个实战场景：
   - 不同的浏览器访问同一个网址展现的内容有差异，简单来说，设置不同的UserAgent就代表不同的浏览器
   - 有些网站含有防爬虫机制，如果不设置UserAgent就无法获取准确的网站内容


### 常见 http 错误
- 301 永久重定向
- 302 临时重定向
- 304 缓存未修改，没有返回值减少带宽
- 401（未授权）未登陆
- 403 权限错误
- 404 找不到资源
- 500 服务器内部错误
- 502 服务超时
- 503 服务不可用
- 504 网关超时

### http， tcp, socket 区别
1. tcp是传输控制协议，位于传输层
2. http协议位于应用层，是一个超文本传输协议；
3.socket是tcp的api，把tcp协议隐藏起来，便于使用；



### cookie和session区别
- cookie
  1. 通俗讲，Cookie是访问某些网站以后在本地存储的一些网站相关的信息，下次再访问的时候减少一些步骤。
  2. 准确的说法是：Cookies是服务器在本地机器上存储的小段文本并随每一个请求发送至同一个服务器，是一种在客户端保持状态的方案。
  3. 主要内容包括：key-value，过期时间，路径和域
- session
  1. 存在服务器的一种用来存放用户数据的类HashTable结构。
  2. 一般这个值会有一个时间限制，超时后毁掉这个值，默认是20分钟。
  - session在服务端保存Session的方法
     内存、数据库、文件都有。
  - 集群的时候需要考虑Session的转移，
     在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候Session信息都是放在内存的，比如redis
  - 服务端如何识别特定的客户
     1. 客户端的cookie存放session。
     2. 当客户端禁用cookie时，通过url重写实现， url后追加sid=xxxxx 这样的参数
     
### 跨域问题
- CORS全称叫跨域资源共享。Cross-origin resource sharing
   1. 在正式的跨域请求之前，先发送了一个OPTIONS请求去询问服务器是否允许接下来的跨域请求.同时携带的内容有：
     Access-Control-Allow打头的几个字段：
       Origin：允许哪些域来访问（*表示允许所有域的请求）
       Methods：允许哪些请求方式
       Headers：允许哪些请求头字段
       Credentials：是否允许携带Cookie
   2. 服务器在响应字段中来表明是否允许这个跨域请求，浏览器收到后检查如果不符合要求，就拒绝后面的请求
   3. 浏览器接到允许后，在向服务器请求内容。
- 优化
   1. 简单请求(head,get,post)就直接发起请求，只需在请求中加入Origin字段表明自己来源，在响应中检查
      Access-Control-Allow-Origin，如果不符合要求就报错，不需要再单独询问了
   2. 服务器响应字段增加一个Access-Control-Max-Age，它表明了这个询问结果的有效期，后面浏览器在有效期内也可以不必再次询问。
- 如何配置
```
@Configuration
public class CorsConfig implements WebMvcConfigurer {
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
                .allowedOrigins("*")
                .allowCredentials(true)
                .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
                .maxAge(3600);
    }
}
```
   
### https
- 传输原理
   使用了非对称加密(一对公私钥进行加密解密)进行私钥传输,
   使用对称加密进行内容传输。
   证书即一对公钥和私钥
   
- https优点：
   1、使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；
   2、HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 http 协议安全，
       可防止数据在传输过程中不被窃取、改变，确保数据的完整性。
   3、HTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本

- 缺点：
   1.HTTPS 协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用
   2.HTTPS 协议还会影响缓存，增加数据开销和功耗; HTTPS连接缓存不如HTTP高效。
   3.HTTPS 连接服务器端资源占用高很多，握手阶段比较费时对网站的相应速度有负面影响。
   4.SSL 证书需要钱。功能越强大的证书费用越高。个人网站、小网站没有必要一般不会用。
   
- HTTPS 是如何实现安全传输数据的
    1. HTTPS 其实就是在HTTP跟TCP中间加多了一层加密层TLS/SSL。
    2. SSL是个加密套件，负责对HTTP的数据进行加密。TLS是SSL的升级版。现在提到HTTPS，加密套件基本指的是TLS。
    3. 原先是应用层将数据直接给到 TCP 进行传输，现在改成应用层将数据给到TLS/SSL，将数据加密后，再给到TCP进行传输。

- HTTPS 安全证书是怎么来的
国内和国外有哪些第三方机构提供安全证书认证。

- https链接建立过程 (加密算法和证书 + 密钥传输 + 验证消息)
1.client--> server:443.发送握手信息: 主要是随机值1 + 客户端支持的加密算法。
2.server--> client    响应握手信息: 包括随机值2 + 匹配好的协商加密算法(client发送给server加密算法的子集)。
3.server-->client  第二个响应报文是数字证书。
     服务端必须要有一套数字证书，可以自己制作，也可以向组织申请。
     区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，
     这套证书其实就是一对公钥和私钥。
     传送证书，这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间、服务端的公钥，第三方证书认证机构(CA)的签名，服务端的域名信息等内容。
4.client解析证书 + 组装密钥
     由客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。
     如果证书没有问题，那么就生成一个随即值（预主秘钥）。
     客户端组装会话秘钥，通过随机值1、随机值2组装。然后通过证书的公钥加密会话秘钥。
6.client-->server 传送加密信息，
    这部分传送的是用证书加密后的会话秘钥，目的就是让服务端使用秘钥解密得到随机值1、随机值2和预主秘钥。
7.server解密.得到随机值1、随机值2和预主秘钥，然后组装会话秘钥，跟客户端会话秘钥相同。
8.client-->server 通过会话秘钥加密一条消息，主要验证服务端是否正常接受客户端加密的消息。
9.server-->client 通过会话秘钥加密一条消息回传给客户端，如果客户端能够正常接受的话表明SSL层连接建立完成了。

- 怎么保证保证服务器给客户端下发的公钥是真正的公钥,而不是中间人伪造的公钥呢
  使用第三方提供的安全证书。


### 输入url后的过程
1. 应用层DNS解析域名，获得对端IP地址
      域名查找顺序：本地缓存->系统缓存->浏览器缓存->ISP缓存->根域名服务器->主域名服务器
2. 应用层客户端发送HTTP请求
3. 传输层TCP传输报文
4. 网络层IP协议查询MAC地址
     IP地址和MAC地址是一一对应关系。ARP协议就是讲IP协议转换成MAC地址的协议，利用ARP协议，找到MAC地址，
     当通信的双方不在同一个局域网时，还需要多次中转，才能到达目标，在中转时，通过下一个MAC地址来搜索下一个中转目标。
5. 数据到达链路层
     找到对方的MAC地址后，就将数据包放到链路层进行传输，封装上链路层特有的报头，然后交付给物理层，物理层通过实际的电路如双绞线进行传输
