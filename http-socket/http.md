### 3次握手和4次挥手  
- 3次握手  syn=1 seq=x， ack=x+1
    2次握手，可能导致server端开启一个过期连接，浪费资源；(client 第一次请求延迟到达，client端已经放弃这个请求了，此时server端收到后确认后没3次握手就开启连接)
- 4次挥手 fin=x，ack=x+1
    因为tcp是全双工模式，接收到FIN意味着没有数据发送过来了，但是还可以继续发送数据。
    
- 常用的三个状态是：
   - ESTABLISHED 表示正在通信，
   - TIME_WAIT 表示主动关闭(client去server请求完毕，client主动close后，client处于time_wait)，
       - 解决办法
          通过调整内核参数和适当的设置web服务器的keep-Alive值来解决， 不是由于程序错误导致；
   - CLOSE_WAIT 表示被动关闭(client去server请求被拒绝，server主动close后，client处于close_wait)。
       - 解决办法
          关闭正在运行的程序，这个需要视业务情况而定。
          尽快的修改程序里的bug，然后测试提交到线上服务器。
          
- 为什么要有time_wait,直接关闭不可以吗？
   - 1.TCP要保证在所有可能的情况下使得所有的数据都能够被正确送达，TIME_WAIT机制能够保证所有的数据都被传输。
       - 1.TIME_WAIT机制保证最后的一个ACK能够正常传输
            - 如果主动关闭的socket不维持这种状态而是进入close状态，那么主动关闭的一方在收到被动关闭方重新发送的FIN时则响应给被动方一个RST。
              被动方收到这个RST后会认为此次回话出错了，无法完成4次挥手正确关闭。
       - 2.TIME_WAIT机制保证网络上残余的数据包被抛弃
            - 这样可以防止同一个ip:port重复建立连接时使用参与数据包
            - time_wait状态的socket在等待2MSL时间后（确认一个数据报及其响应的丢弃需要两倍的MSL。MSL(Maximum Segment Lifetime)报文最长存活时间，是一个数据报在网络中单向发出到认定丢失的时间），将会转为closed状态。
### http1.0。http1.1。 http2
- http1.0
      每个TCP连接只能发送一个请求
- http1.1
   优点：
    - 引入了长连接，即TCP连接默认不关闭，可以被多个请求复用
    - 管道化，在同一个TCP连接里面，客户端可以同时发送多个HTTP请求，而不用等待一个个响应
    - 支持 断点续传
   缺点："队头堵塞"
    - 虽然1.1版允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。
      服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。
- http2
   - 多路复用：
      多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行
   - 服务器推送：
       服务器未经请求，主动向客户端发送资源，这叫做服务器推送


### http
1.发送header中几个字段：  
Content-Type字段，表明传输类型；  
boundary字段，表明各个参数中间的分隔符 
Content-Disposition： content-type字段的进一步说明； 




### http代理
- 即使通过了重重代理，请求头都会原封不动的发给服务器，响应头也会原样被客户端收到。
- HTTP 中的 Connection，用来对 HTTP 连接(端到端的一次连接)进行说明，多个说明使用英文逗号隔开，用完就删除；
  所以，如果有多个代理的话，必须在报文转给下个节点之前删除;
  
- 互联网上，存在着大量简陋并过时的代理服务器在继续工作，它们很可能无法理解 Connection中的一些字段。
  而代理服务器在遇到不认识的 Header时，往往都会选择继续转发,例如connection:keep-alive;
  
- 显式给浏览器设置代理后，浏览器会把请求头中的 Connection 替换为 Proxy-Connetion。
  这样，对于老旧的代理，它不认识这个 Header，会继续发给服务器，服务器也不认识，代理和服务器之间不会建立持久连接（不能正确处理 Connection 的都是 HTTP/1.0 代理），服务器不返回 Keep-Alive，代理和浏览器之间也不会建立持久连接。
  而对于新代理，它可以理解 Proxy-Connetion，会用 Connection 取代无意义的 Proxy-Connection，并将其发送给服务器，以收到预期的效果
  

### 用户代理 UserAgent
同样一个地址，如果设置UserAgent与不设置两者返回的结果是不一样的，例如以下几个实战场景：
   - 不同的浏览器访问同一个网址展现的内容有差异，简单来说，设置不同的UserAgent就代表不同的浏览器
   - 有些网站含有防爬虫机制，如果不设置UserAgent就无法获取准确的网站内容


### 常见 http 错误
- 401（未授权）未登陆
- 403 权限错误
- 500 服务器内部错误
- 502 网关错误
- 503 服务不可用
- 504 网关超时

### http， tcp, socket 区别
1. tcp是传输控制协议，位于传输层
2. http协议位于应用层，是一个超文本传输协议；
3.socket是tcp的api，把tcp协议隐藏起来，便于使用；

### tcp拥塞控制机制
- 概念
    TCP的拥塞控制机制是从端到端的角度，推测网络是否发生拥塞，如果推断网络发生拥塞，则立即将数据发送速率降下来，以便缓解网络拥塞。
- 拥塞控制
    TCP的拥塞控制采用的是窗口机制，通过调节窗口的大小实现对数据发送速率的调整。
    TCP的发送端维持一个称为拥塞窗口cwnd的变量，单位为字节，用于表示在未收到接收端确认的情况下，可以连续发送的数据字节数。
- 拥塞窗口调整：
    只要网络没有出现拥塞，就可以增大拥塞窗口，提高发送速率；一旦网络出现拥塞，拥塞窗口就减小一些，减少注入网络的数据量。
- 判断网络发生拥塞的依据是：
    发送端设置一个重传计时器RTO，对于某个已发出的数据报文段，如果在RTO计时到期后，还没有收到来自接收端的确认，则认为此时网络发生了拥塞
- 拥塞控制算法
   慢启动(采用试探的方法，逐渐增大拥塞窗口，阈值前每次翻倍)、拥塞避免(阈值后每次加1，拥塞后减半)、快速重传(每收到一个失序的数据报文段后就立即发出重复确认,及早发现)和快速恢复(发送端连续收到三个重复确认时，就将慢启动阈值减半)
