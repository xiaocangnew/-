### 常用场景
1.缓存热点数据
2.队列。因为提供了list和set的操作，这使得redis可以作为一个很好的消息队列平台。
3.排行榜，计数器。使用sortedset，找出最高分。
4.发布订阅

### 基本数据结构 String, list, Hash , set, Zset  
- 返回结果(类似mysql的insert，返回影响的行数 1-success   0-fail)
- 通用命令：
   - exists title  
   - del title 
   - expire title 
- 模糊搜索 KEYS pattern (线上避免使用，会单线程扫描全局)
    - ?：用于匹配单个字符。例如，h?llo可以匹配hello、hallo和hxllo等；
    - *：用于匹配零个或者多个字符。例如，h*llo可以匹配hllo和heeeello等；
    - []：可以用来指定模式的选择区间。例如h[ae]llo可以匹配hello和hallo，但是不能匹配hillo。
- 模糊搜素：SCAN startIndex pattern count 10 (10为单次遍历的字典槽位，不是slot);
    - SCAN命令是一个基于游标的迭代器。这意味着命令每次被调用都需要使用上一次这个调用返回的游标作为该次调用的游标参数，以此来延续之前的迭代过程。
#### String:  
 - 存储：字符串，整数，浮点数
 - 操作：字符串可以操作一部分，  整数浮点进行自增自减
 - 命令：set key value // get key // del key 
   incr key (可选步长) //decr key (可选步长)
#### List   （适用于最新消息排行，消息队列等）
 - 存储：字符串的链表
 - 操作：lpush key value（返回列表的大小）// lpop key 
   lrange title index0 index1 
   lindex title index(正数为从左边数起，负数为从右边数起)
#### Set （适用于共同好友，利用唯一性统计ip，）
 - 存储：独一无二的字符串
 - 操作：增删改查，计算交并差集合，随机获取元素
 - 命令：sadd title val1 val2 // srem title value
   sismember title value 
   smembers title (获取所有元素)
#### Zset   （适用于排名积分等）
 - 操作：字符串成员与浮点数分值之间的有序映射
 - 操作：增删改查，可以通过分值，或者成员来访问
 - 命令：zadd title score member // zrem title member
   zrange title index1 index2  /  zrangebyscore title score1 score2
   zcard title 返回size
#### Hash
 - 存储：键值对
 - 操作：增删改查
 - 命令：hset title key value / hget title key   / hdel title key
   hgetall title 

注意：1.redis自动创建和删除title，   直接 lpush title value,    如果title为空后，自动删除
 2.hset是每次只设置一个键值对， hmset可以设置多个键值对，hmset title key1 value1 key2 value2
3.blockingList 
命令：brpop  blpop 实现阻塞式list，如果list为空，一值阻塞，或者阻塞一段时间后返回
4. 这里的title key value ==> key field value
5.redis 的操作都是原子性的
6.object encoding title 查看底层存储的数据结构

###连接服务器：
 redis-cli -h host -p port -a password
 
### redis 底层数据结构
- 简单动态字符串（SDS）
- 整数集合
- 字典
    - 结构
      dictEntry={key, val, nextEntry};
      dictHt={entryTable[], size, sizemask(index), usedEntryCount}
      dict={dictType, privdata, dictHt[2](ht[1]只有在对ht[0]哈希表进行rehash操作时使用),trehashidx（rehash索引，没有进行rehash操作时值都为-1)}
    - rehash
      1）为字典的ht[1]哈希表分配空间，空间大小根据实际情况而定；
      2）将ht[0]中所有键值对rehash到ht[1]中
      3）释放ht[0]，将ht[1]设置为ht[0]，并在ht[1]新建一个空表，为下次rehash做准备
     
- 链表
    双向链表
- 跳跃表
    study-> 算法-> 数据结构中有代码
- 压缩列表  
    - 结构  连续内存块组成
        总结构：zlbytes(总字节长度)->zltail(尾到头地址有多少字节)->zllen(节点数量)-> entryX(各个节点)->zlend(末端)
        节点结构： previous_entry_length -> encoding -> content(一个字节或整数)
    - 连锁更新
        假设压缩列表中所有节点的previous_entry_length属性都是用1字节来保存，那么节点的长度只要小于等于253字节previous_entry_length都可以记录，但是，如果添加一个长度大于253字节的节点，那么下一个节点的previous_entry_length就无法保存该长度的值，同样的，下下个节点也无法保存上个节点的长度，由此将导致连续多次空间扩展操作。
        添加节点和删除节点都可能导致连锁更新，但是这种操作出现的几率很低。
    - 优缺点
       为节省内存而设计的内存结构，它的优点就是节省内存，但缺点就是比其他结构要消耗更多的时间，

 
### redisObject  
- redis并没有使用'底层数据结构'来实现k-v对，而是又包装了一层redisObject
- 主要的信息包括
    - 1.数据类型（type）
         五种基本的：string, list, hash, set, zset
    - 2.编码方式(encoding)  对应基础数据类型
         - string：int->embstr--(32字节限)-->raw
              - 既然有了raw的编码方式，为什么还会有embstr的编码方式呢？
                1. 创建对象时，embstr内存分配次数从raw的两次降低为一次。
                2. 释放字符串对象时，embstr调用一次内存释放函数，raw调用两次。
                3. 连续的内存占用
         - hash： ziplist、hashtable
         - list： ziplist、linkedlist。
         - set : intset、hashtable。
         - sortedSet: ziplist、skiplist。
    - 3.数据指针（ptr）： 
          指向实际值的指针
    - 4.引用计数器
          refcount表示引用计数，由于C语言并不具备内存回收功能，所以Redis在自己的对象系统中添加了这个属性，
          当一个对象的引用计数为0时，则表示该对象已经不被任何对象引用，则可以进行垃圾回收了。
    - 5.lru：
          对象最后一次被命令程序访问的时间。
